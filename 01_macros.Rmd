# Macros {#macro}
```{r setup2, echo = F, message=F, warning = F}
if(Sys.getenv("USERNAME") == "Filser" ) .libPaths("D:/R-library4")  # set library
# stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
stataexe <- "C:/Program Files/Stata16/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
library(Statamarkdown)
# library(tidyverse)
# library(ggthemes)
```


Macros ist die Sammelbezeichung für `global`s und `local`s in Stata.
Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen.
Definiert werden sie durch `global `*inhalt* oder `local `*inhalt* - oft mit `glo` und `loc` als Abkürzungen.
`global`s können dann mit `$globalname`/`${globalname}` aufgerufen werden, `local`s mit ``localname'` - ganz einfach bspw. mit `dis[play]`:
```{stata mac0}
glo x = 1
loc y = 2

dis ${x}
dis `y'
```

...oder mit `macro list`, hier sind die macros aber ohne "punctuation" (also `$` oder ``'`)
```{stata mac1}
glo x = 1
loc y = 2
mac list x
mac list _y
```

Der Unterschied besteht vor allem darin, dass *local* macros 'lokal' für ein spezifisches Programm verfügbar sind, *globale* macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind.
Letztlich können wir jede Instanz, in der wir mehrere Zeilen eines DoFiles ausführen als 'Programm' ansehen. 

`global`s können wir später nochmal aufrufen, `local`s nicht:
```{stata macloc, eval =F}
mac list xg
```

```{stata macloc2, echo =F,error=T}
glo xg = 1
mac list xg
```

```{stata macloc1, eval =F}
mac list _xl
```

```{stata macloc12, echo =F,error=T}
mac list _xl
```


## `=` macht einen Unterschied

In der Regel können wir auch einfach `glo glname Wert` bzw. `loc locname Wert` statt `glo glname = Wert` bzw. `loc locname = Wert` angeben.
Allerdings ist hier etwas Vorsicht geboten, denn das `=` ist entscheidend ob  die Rechnung abgelegt wird oder das Ergebnis (*Stichwort evaluation*):
Im Ergebnis sehen wir hier beides Mal das gleiche:
```{stata mac2, echo = T}
local m1 2+2
display `m1'
```
```{stata mac2b, echo = T}
local m2 = 2+2
display `m2'
```
Aber wenn wir uns mit `mac list` die abgelegten Infos ansehen, dann sehen wir den entscheidenden Unterschied:
```{stata mac3, eval = F}
mac list _m1 _m2
```
```{stata mac3b, echo = F}
local m1 2+2
local m2 = 2+2
mac list _m1 _m2
```


Wenn wir nämlich mit `m1` und `m2` weiterrechnen, da kann folgendes passieren:
```{stata mac4, echo = T}
local m1 2+2
display `m1'*4
```
```{stata mac4b, echo = T}
local m2 = 2+2
display `m2'*4
```
Denn $2+2*4\neq4*4$ 

## `local` und `global` sind getrennte Welten

Geht, aber ist nicht zu empfehlen:
```{stata mac5a1}
glo yx = 1
loc yx = 2
mac list yx
mac list _yx
```

## Macros mit Text

Wir können macros zu Texten zusammenbauen:
```{stata macrobau0}
glo t1 "Hallo"
glo t2 " zusammen"
glo t3 "! :-)"

glo t4 = "${t1}${t2}${t3}"
dis "${t4}"
mac list t1 t2 t3 t4
```

## Dateipfade 

Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden:

```{stata mac8, eval=F}
glo pfad "D:\Projekt\daten\BIBB_BAuA" // wo liegt der Datensatz?
use "${pfad}/BIBBBAuA_2018_suf1.0.dta", clear // laden des Datensatzes 
```

Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden:
```{r pfadillu, echo = F,out.width = "80%",fig.height= 3, fig.align="center"}
knitr::include_graphics("./pics/01_pfade.png")
```

```{stata mac8dir1, eval=F}
glo pfad "C:\Projekte\Micha" // wo liegt der Datensatz bei Alex?
glo pfad "D:\Arbeit\Alex"    // wo liegt der Datensatz bei Micha?

glo prog "${pfad}/prog"  
glo data "${pfad}/data"
glo log  "${pfad}/log"
```
Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. 
Wir lernen [gleich](#if1) noch eine Möglichkeit kennen, das auch direkt mit zu lösen mit dem Usernamen der verwendeten PCs.

```{stata mac8dir2, eval=F}
use "${data}/BIBBBAuA_2018_suf1.0.dta", clear // laden des Datensatzes 
```

Bei Dateipfaden ist [jedoch `\` beim Zusammenbauen mit macros manchmal problematisch](#dir)). Ggf. hilft hier `/` statt `\` zu verwenden.

## Bereits definierte Macros

Mit `mac list` bekommen wir auch einige von Stata bereits vorgegebenen Macros angezeigt.
```{stata mac5a, eval = F}
mac list
```

Zwei sehr nützliche sind dabei `$S_DATE` `$S_TIME` - das aktuelle Datum und die aktuelle Zeit:
```{stata mac5, eval = F}
dis "$S_DATE"
dis "$S_TIME"
```
```{stata mac5disp, eval = F}
1 Dec 2021 
12:44:22
```


Diese können wir beispielsweise am Anfang und Ende eines LogFiles einblenden, um Start- und Endzeit zu dokumentieren:
```{stata mac5log, eval = F}
log using "${log}/logfile.txt", t replace
dis "Start: $S_DATE um $S_TIME"
use ....
.
.
.
.
.
.
dis "Ende: $S_DATE um $S_TIME"
log close 
```

Außerdem gibt es einige `locals` mit nützlichen Infos:
```{stata mac5locs, eval = F}
dis "`c(username)'"
dis "`c(machine_type)'"
dis "`c(os)'"
```

```{stata mac5locsT, eval = F}
Filser
PC (64-bit x86-64)
Windows
```


Weitere "system parameters and settings" unter `help creturn` bspw.:
`c(changed)` returns a numeric scalar equal to 0 if the dataset in memory has not changed since it was last saved and 1 otherwise. 
`c(filename)` returns a string containing the filename last specified with a use or save, such as `"C:\Data\auto.dta"`. 
`c(filedate)` returns a string containing the date and time the file in `c(filename)` was last saved, such as "7 Jul 2016 13:51". 


### `if` {#if1}

Mit `if (`local` == "...")` können wir macros abgleichen, um Befehle nur unter bestimmten Bedingungen auszuführen:
```{stata macAM1, eval = F}
if ("`c(username)'" == "Filser")  display "Du bist Filser"
if ("`c(username)'" != "Fischer") display "Du bist nicht Fischer"
```


Das können wir für den Fall von eben mit mehreren Nutzern nutzen:
```{stata macAM2, eval = F}
if ("`c(username)'" == "Alex")   glo pfad "C:\Projekte\Micha" // wo liegt der Datensatz bei Alex?
if ("`c(username)'" == "Micha")  glo pfad "D:\Arbeit\Alex"    // wo liegt der Datensatz bei Micha?

glo prog "${pfad}/prog"  
glo data "${pfad}/data"
glo log  "${pfad}/log"

use "${pfad}/BIBBBAuA_2018_suf1.0.dta", clear // laden des Datensatzes 
```



### Macros als Variablennamen und Befehle

Auch so etwas ist möglich:
```{stata macrobau1,eval = F}
local n 200
su F`n'
```


```{stata macrobaut,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
local n 200
su F`n'
```

Ein macro kann auch ein Programm sein:
```{stata mac8b, eval=F}
loc t tab
`t' zpalter
```

```{stata mac8b1, echo=F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
loc t tab
`t' mobil
```

### `globals` durchsuchen {#allglo}


Mit Hilfe sog. Wildcards können wir Zeichen "offen lassen":

`?` ersetzt ein Zeichen
`*` mehrere oder keines

```{stata macall}
glo x1 = 2
glo x2 "das ist x2"
glo x 291
global allglo:  all globals "x*"
mac l allglo
```

Hier haben wir auch schon die dritte Form der macro Definition kennengelernt, die sog. `extended macro function`, welche auf `:` folgt. Hier also `all globals`, im Laufe dieses Kurses werden wir noch zahlreiche dieser Funktionen kennenlernen. 

***

**[Übung 1](#ue1)**

***

## Wenn nicht `if`, dann `else`

Mit `if` haben wir die Möglichkeiten aber noch nicht ausgeschöpft - aus `help if`:
```{stata ifelseif, eval = F}
if `n'==1 {
	local word "one"
     }
else if `n'==2 {
	local word "two"
}
else if `n'==3 {
	local word "three"
}
else {
	local word "big"
}
display "`word'"
```

Mit `exit` (`help exit_program`) können wir Stata zu einer Unterbrechung bringen:

>   More generally, exit causes Stata to terminate the current process and returns control to the calling process.

```{stata ifelseif2}
if "`c(username)'" == "Alex" {
  glo pfad "C:\Projekte\Micha" // wo liegt der Datensatz bei Alex?
	} 
else if "`c(username)'" == "Micha" {
  glo pfad "D:\Arbeit\Alex"    // wo liegt der Datensatz bei Micha?
}
else {
 display as error "Hier fehlt der passende Pfad"
 exit 
}
```



## Schleifen:  `foreach` & `forvalues`

Schleifen helfen uns das DRY ("Don't repeat yourself") Prinzip umzusetzen.

Ein vereinfachtes Syntaxdiagramm der `foreach`-Schleife sieht so aus:
```{stata foreach1, eval = F}
foreach lname listtype list {
  Befehle
}
```

`lname` steht dabei für ein `local` macro.

Wir können unterschiedliche Typen von `foreach`-Listen verwenden:
– `of varlist`: Variablenlisten
– `of newlist`: neue Variablen
– `of numlist`: Nummernlisten - bspw. `(0(1)5)` $\Rightarrow$ "1 bis 5 in Schritten von 1" 
– `in`: beliebige Listen von Buchstaben, Zahlen oder Wörtern (durch Leerzeichen getrennt)


```{stata foreachn}
foreach n of numlist 1/3 6(1)9  {
    dis "`n'"
}
```

```{stata foreachn2}
foreach n of numlist 6 4: -4  {
    dis "`n'"
}
```

Mit  `ferest()` können wir uns die "noch übrigen Werte in der Liste anzeigen lassen:
```{stata ferest}
foreach n of numlist 1(1)5 {
    dis "`n'"
    dis "Es kommen noch: `ferest()'"
}
```

### Weitere Schleifentypen

Es gibt außerdem `forvalues`:
```{stata forvalues, eval = F}
forvalues lname=range {
  Befehle
}
```

`forvalues`-Schleife ist eine `foreach`-Schleife mit `numlist`.
Aber: Die `foreach`-Schleife mit einer `numlist` funktioniert nicht mit einer beliebig hohen Anzahl von Ziffern.
In der `forvalues`-Schleife gibt es keine Beschränkung. Außerdem ist `forvalues`-Schleife schneller im Abarbeiten von Nummernlisten.

Und dann gibt es noch die `while`-Schleife:

```{stata while}
loc i = 1
while `i' <= 5 {
  display "`i'"
  loc i = `i' + 1
}
```

Eine Besonderheit bei `local`s ist, dass wir mit `loc ++i` den Wert um 1 erhöhen können. Somit führt folgende Syntax zum gleichen Ergebnis:
```{stata while2, eval = F}
loc i = 1
while `i' <= 5 {
  display "`i'"
  loc ++i
}
```


### Anwendung

```{stata tabloop1, eval = F}
foreach v of numlist 19(5)35 {
	display "Alter bis `v'"
	tab S1 if zpalter <= `v'
}
```


```{stata tabloop2, echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear

foreach v of numlist 19(5)35 {
	display "Alter bis `v'"
	tab S1 if zpalter <= `v'
}
```

...oder mit `inrange()`, um lediglich die 5-Jahresaltersgruppe anzuzeigen:
```{stata tabloop3, eval = F}
foreach v of numlist 19(5)35 {
	display "Alter " `v' - 4 " bis " `v'
 	tab S1 if inrange(zpalter,`v'-4, `v')
	*su zpalter if inrange(zpalter,`v'-4, `v')
}
```


```{stata tabloop4, echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear

foreach v of numlist 19(5)35 {
	display "Alter " `v' - 4 " bis " `v'
 	tab S1 if inrange(zpalter,`v'-4, `v')
	*su zpalter if inrange(zpalter,`v'-4, `v')
}
```

### Schleifen aufbauen

Einfache Schleife mit `if`/`else`: ist Zahl gerade oder ungerade?

```{stata loopbuild, eval = F}
loc n = 5
if trunc(`n'/2) == `n'/2 display "ja"
if trunc(`n'/2) != `n'/2 display "nein"

loc n = 5
dis mod(`n',2) 


forvalues n = 1/10 {
	if  mod(`n',2)  == 0 dis "`n' ist gerade"
	if  mod(`n',2)  == 1 dis "`n' ist ungerade"
}

forvalues n = 1/10 {
	if  mod(`n',2)  == 0 {
		dis "`n' ist gerade"
	}
	else if mod(`n',2)  == 1 {
		dis "`n' ist ungerade"
	} 
	else {
		display as error "hier ging was schief"
		exit 
	}
}
```

[mod() ist der Modulo-Operator ist Stata - es wird der "Rest" berechnet](https://de.wikipedia.org/wiki/Division_mit_Rest#Modulo)

***

**[Übung 2](#ue2)**

***

- Variablen & value labels anzeigen/bearbeiten 
- Creating interaction variables
- Fitting models with alternative measures of education
- Recoding multiple variables the same way
- Creating a macro that holds accumulated information
- Retrieving information returned by Stata




## Übungen

### Übung {#ue1}

- Pfad zusammenbauen für `use`: Erstellen Sie den Pfad für den `use`-Befehl schrittweise und unter Berücksichtigung ihres Usernamens.
  - ggf. Dateiverzeichnis einrichten mit Ordner *log*, *prog* und *data* (gerne auch mehr oder andere Namen)
  - Legen Sie die Erwerbstätigenbefragung 2018 in den *data*-Ordner (oder dessen Äquivalent) 
  - Wie ist der Username auf Ihrem Gerät?
  - Verwenden Sie ein `if`-Statement, um den Dateipfad zu erstellen

  
### Übung: FizzBuzz-Challenge {#ue2}

Fizz Buzz wird/wurde ein Screening-Instrument für Programmierer\*innen verwendet. Fizz Buzz ist ein Kinderlernspiel, bei dem die Kinder üblicherweise im Kreis sitzen und reihum laut von eins aufwärts zählen. Allerdings gibt es zwei Regeln:

+ Dabei müssen alle Zahlen, die durch drei teilbar sind, durch das Wort Fizz ersetzt werden und alle Zahlen, die durch fünf teilbar sind, durch das Wort Buzz.
+ Wenn eine Zahl durch drei und fünf teilbar ist, dann wird Fizz Buzz gerufen.


- `if` & `else` für Schleife 
  - 1-10: bei geraden Zahlen "gerade" und bei ungeraden Zahlen "ungerade" anzeigen
Die 





## Windows Dateipfade mit macros {#dir}

[Aus der Stata-Doku zu macros](https://www.stata.com/manuals/u18.pdf#u18.3.11): 

Stata uses the \ character to tell its parser not to expand macros.
Windows uses the \ character as the directory path separator.
Mostly, there is no problem using a \ in a filename. However, if you are writing a program that contains a Windows path in macro path and a filename in fname, do not assemble the final result as `‘path’\‘fname’` because Stata will interpret the \ as an instruction to not expand `‘fname’`. 
Instead, assemble the final result as `‘path’/‘fname’`.
Stata understands `/` as a directory separator on all platforms.

$\Rightarrow$ 


## Details

### `local x` entspricht `global _x`

Theoretisch kann man auch mit `global _x` einen `local x` erzeugen:
```{stata det0a, eval= F}
local   x = 2
global _x = 3

dis 
```


```{stata det0b, eval= F}
local i=1 
global _i=1
```

Damit könnte man auch so alle `locals` auflisten:

```{stata alllocas, eval = F}
glo x1 = 2
glo x2 "das ist x2"
glo x 291
global allglo:  all globals "_x*"
mac l allglo
```




```{stata det1, eval= F}
global a "myvar"
gen $a = oldvar   gen myvar = oldvar
gen a = oldvar    gen a = oldvar

local a "myvar"
gen ‘a’ = oldvar gen myvar = oldvar

gen a = oldvar gen a = oldvar
global a "newvar"
global i = 2
gen $a$i = oldvar gen newvar2 = oldvar
local a "newvar"
local i = 2
gen ‘a’‘i’ = oldvar gen newvar2 = oldvar
global b1 "newvar"
global i=1
gen ${b$i} = oldvar gen newvar = oldvar
local b1 "newvar"
local i=1
gen ‘b‘i’’ = oldvar gen newvar = oldvar
global b1 "newvar"
global a "b"
global i = 1
gen ${$a$i} = oldvar gen newvar = oldvar
local b1 "newvar"
local a "b"
local i = 1
gen ‘‘a’‘i’’ = oldvar gen newvar = oldvar
```

