# Schleifen aus Macros {#loopmacro}
```{r setup2, echo = F, message=F, warning = F}
if(Sys.getenv("USERNAME") == "Filser" ) .libPaths("D:/R-library4")  # set library
# stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
stataexe <- "C:/Program Files/Stata16/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
library(Statamarkdown)
library(kableExtra)
library(magrittr)
# library(tidyverse)
# library(ggthemes)
```


## local erstellen und für Schleifen verwenden

Schleifen aus globals / locals mit Hilfe von `levelsof`:
```{stata mlo1, eval =F}
tab m1202
levelsof m1202

levelsof m1202, loc(ausb)
foreach lvl  of local ausb {
	dis "m1202: " `lvl'
}


levelsof m1202, loc(ausb)
glo ausb `ausb'
mac l ausb

foreach lvl  of global ausb {
	dis "m1202: " `lvl'
}


foreach lvl  of global ausb {
	dis "m1202: " `lvl'
	tab S1 if m1202 == `lvl'
}
```



## Informationen aus Schleifen behalten

### Gespeichterte Ergebnisse

Um auf Ergebnisse zuzugreifen, können wir etwas hinter die Kulissen der Stata-Befehle sehen: 

```{r tib1, echo=F}
tibble::tribble(~"Befehl",~"zeigt alle",
"c-class", "system parameters & settings finden wir als `c()` - siehe [``c(username)'`](#cmac)",
"r-class", "die meisten deskriptiven Befehle speichern die Ergebnisse in in `r()`",
"e-class", "...außer estimation commands, wie bspw. `reg` - hier wird in `e()` gespeichert (Postestimates)",
"s-class", "parsing commands store results in `s()` used by programmers",
"n-class", "commands that do not store in `r()`, `e()`, oder `s()`") %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "condensed", full_width = F,font_size = 12) %>% 
  column_spec(1,monospace = TRUE) %>% 
  row_spec(0, color = "white")
```

Jeweils alle Werte anzeigen mit:

```{r tib2, echo=F}
tibble::tribble(~"Befehl",~"zeigt alle",
 "return list",   "r()",
"ereturn list",   "e()",
"sreturn list",   "s()",
"creturn list",   "c()") %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "condensed", full_width = F,font_size = 12) %>% 
  column_spec(1:2,monospace = TRUE)
```

Es gibt dabei vier Typen an Ergebnissen:

+ `macro`:  strings mit mehreren Wörtern (Text)
+ `matrix`: bspw. `e(b)` sind die Koeffizienten nach einem `reg`-Befehl oder `e(V)` ist die Varianz–Kovarianz Matrix der estimates (VCE)
+ `scalar`: einzelne Zahlen/Strings (1x1 Matrizen)
+ `functions`: bspw. `e(sample)` $\Rightarrow$ 1 (true) wenn die Beobachtung im vorheringen "estimation command" verwendet wurde und 0 (false) wenn nicht

```{stata retlist, eval= F}
tab S1
return list
```
```{stata retlist0,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
tab S1
return list
```

```{stata retlist2, eval= F}
su S1
return list
```
```{stata retlist02,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
su S1
return list
```

```{stata retlist3, eval= F}
reg F518_SUF zpalter 
ereturn list
```
```{stata retlist03,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
}
reg F518_SUF zpalter 
ereturn list
```

Anstatt zu versuchen, den Überblick darüber zu behalten, was wo gespeichert wird, finden woe ganz unten in jeder Hilfedatei einen Hinweis wie
"`summarize` stores the following in `r()`:" or "`mean` stores the following in `e()`" - entsprechend sehen wir die Ergebnisse in `return` bzw. `ereturn`.

### `e()` und `r()` sind getrennte Welten

Neben dem Prinzip "One Data" folgt Stata auch dem Prinzip "One _-class".
Das bedeutet, dass wir nur den return oder ereturn für den letzten Befehl dieser Klasse sehen können.
Wenn wir also `reg` ausführen und dann eine Reihe von r-Klassen-Aufrufen machen (z.B. `su`), wird uns der Aufruf von `ereturn` immer noch die Werte für `reg`` anzeigen. 
Sobald wir jedoch einen weiteren r-class-Befehl ausführen, verlieren wir den Zugriff auf die Ergebnisse des ersten Befehls. 
```{stata erl0, eval = F}
reg az F200
su az
ereturn list
```


```{stata erl01,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
}
reg az F200
su az
ereturn list
```

<!-- https://cscar.github.io/workshop-stata-intro/programming-advanced-features.html -->

### Ergebnisse weiter verwenden

Alle diese Informationen können wir mit einem Makro speichern bzw. weiter verarbeiten. 

```{stata retlist4, eval= F}
su S1
dis "Mittelwert beträgt: " r(mean)
```
```{stata retlist04,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
qui su S1
dis "Der Mittelwert beträgt: " r(mean)
```

```{stata retlist5, eval= F}
su S1
dis "Mittelwert beträgt: " round(r(mean),.01)
```

```{stata retlist05,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
qui su S1
dis "Der Mittelwert beträgt: " round(r(mean),.01)
```

```{stata mloretn, eval = F}
foreach lvl  of global ausb {
	dis "m1202: " `lvl'
	su S01 if m1202 == `lvl'
	dis r(mean)
}

foreach lvl  of global ausb {
	qui su S01 if m1202 == `lvl'
	dis "Der Frauenanteil in m1202=" `lvl' " beträgt: " round(r(mean)*100,.1) "%"
}


foreach lvl  of global ausb {
	qui su S01 if m1202 == `lvl'
	glo gend`lvl': display "Der Frauenanteil in m1202=" `lvl' " beträgt: " round(r(mean)*100,.1) "%"
}
```


Macros können auch "recursively" erstellt werden:
```{stata mloretn2}
global x ""
forvalues i = 1/20 {
	global x $x `i'
}
mac list x
```

...somit können wir einen `global` auch zusammenbauen:
```{stata mloretn3, eval = F}
glo gend ""
foreach lvl  of global ausb {
	qui su S01 if m1202 == `lvl'
	glo gend: display "${gend}m1202=" `lvl' " " round(r(mean)*100,.1) "% "
}
mac l gend
```

```{stata mloretn3b, echo = F}
quietly{
  use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
  drop if m1202 < 0
  tab m1202
  levelsof m1202
  levelsof m1202, loc(ausb)
  glo ausb `ausb' 
  gen S01 = S1-1
} 

glo gend ""
foreach lvl  of global ausb {
	qui su S01 if m1202 == `lvl'
	glo gend: display "${gend}m1202=" `lvl' " " round(r(mean)*100,.1) "% "
}
  
mac l gend
```

## `matrix`

Matrizen helfen uns, die ergebnisse in handhabarer Form zu speichern (`help matrix`).

- eine `matrix` ausgeben:
`matrix list matname`

- eine `matrix` umbenennen:
`matrix umbenennen altername neuername`

- eine `matrix` oder alle löschen:
`matrix drop [matlist]`

Mit `J(Zeilen,Spalten,Inhalt)` können wir eine Matrix mit gleichen Werten besetzen:
```{stata matrix04}
mat G0 = J(4,2,0)
mat l G0
```
... mit `.` in allen Zellen:
```{stata matrix04b}
mat Gx = J(4,2,.)
mat l Gx
```

Mit `mat name[Spalte,Zeile]` können wir auf einen Teilbereich zugreifen:
```{stata matrix04c}
mat A = J(4,2,7)
mat A[3,2] = 2
mat list A
```


Das nutzen wir jetzt um unsere Ergebnisse zu speichern:
```{stata matrix05, eval = F}
levelsof m1202, loc(ausb)
glo ausb `ausb'

mat G = J(4,2,.) // leere Matrix 
mat l G
mat colname G = m1202 share_w
mat l G

foreach lvl  of global ausb {
	qui su S01 if m1202 == `lvl'
	mat G[`lvl',1] = `lvl'  // 1. Spalte level von m1202
	mat G[`lvl',2] = r(mean)*100 //2.Spalte: Frauenanteil
}
```

`help matrix operators` 

```{r trib3,echo=F}
tibble::tribble(~"Operator",~"Symbol",
                "column join"            ,",",
                "row join"               ,"\\\\ \ ", 
                "transpose"              ,"'",
                "negation"               ,"\\- "
                ) %>% 
  kable() %>% 
  kable_styling(bootstrap_options = "condensed", full_width = F,font_size = 12) %>% 
  column_spec(2,monospace = TRUE) 
            
```

```{stata mat01}
matrix Y1 = 1, 3 
mat l Y1
```

```{stata mat02}
matrix Y2 = 4\ 0
mat l Y2
```


```{stata mat03}
matrix Y = (2, 1.5 \ 2.5, 3)
mat l Y
```

Wir können auch Rechnungen einfügen:
```{stata mat04}
matrix X1 = (1+1, 2*3/4 \ 5/2, 3)
mat l X1 
```

Transponieren:

```{stata mat05}
matrix X2 = (1, 2, 3 \ 5 , 8 , 9)
mat l X2 
mat X3 = X2'
mat l X3
```
## mehrere Kennzahlen ablegen

Damit können wir zeilenweise eine `matrix` befüllen:
```{stata tm12, eval = F}
mat G2 = J(4,5,.) // leere Matrix 
mat l G2
mat colname G2 = m1202 p25 mean median p75 
mat l G2

foreach lvl  of global ausb {
	qui su zpalter if m1202 == `lvl', det
	mat GX = `lvl', r(p25), r(mean), r(p50), r(p75) 
	mat G2[`lvl',1] = GX
}
mat l G2
```


```{stata tm12b, echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode zpalter, mv(9999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
}
mat G2 = J(4,5,.) // leere Matrix 
mat colname G2 = m1202 p25 mean median p75 
qui levelsof m1202, loc(ausb)
foreach lvl  of local ausb {
	qui su zpalter if m1202 == `lvl', det
	mat GX = `lvl', r(p25), r(mean), r(p50), r(p75) 
	mat G2[`lvl',1] = GX
}
mat l G2
```

***

**[Übung](#retue1)**

***

## Matrixoperationen

### Teilmatrizen

```{stata tm01}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
mat l X1
```


Wir können aus diesen Matrizen auch Teilbereiche auswählen:
```{stata tm02, eval = F}
matrix newmat = oldmat[Zeile(nbereich), Spalte(nbereich)]
```
Zeilenbereich und Spaltenbereich können einzelne Zahlen oder Bereiche mit durch zwei Punkte getrennten Start- und Endpositionen sein.

Matrix B erstellen, welche die Zeile 2-4 und die Spalte 1-5 von X1 enthält:
```{stata tm03, eval = F}
matrix B = X1[2..4,1..5]
mat l B
mat l X1
```
```{stata tm04, echo = F}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
matrix B = X1[2..4,1..5]
mat l B
mat l X1
```

Um alle Zeilen nach der zweiten Zeile zu übernehmen, verwenden wir drei Punkte:
```{stata tm05, eval = F}
matrix C = X1[2...,1..5]
mat l C
mat l X1
```

```{stata tm06, echo = F}
qui mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
matrix C = X1[2...,1..5]
mat l C
mat l X1
```

<!-- * https://thedatamonkey.blogspot.com/2011/01/stata-matrices.html -->

```{stata tm08}
matrix A = J(3,4,.) 
mat li A
```


```{stata tm09}
mat A1 = (1, 4, 2, 1) 
mat li A1
```

```{stata tm10, eval = F}
mat A[1,1]  =A1 // !! überschreibt die ganze 1. Zeile
mat li A
```

```{stata tm11, echo = F}
matrix A = J(3,4,.) 
mat A1 = (1, 4, 2, 1) 
mat A[1,1]  =A1 // !! überschreibt die ganze 1. Zeile
mat li A
```

### `matrix` zu Datensatz

`svmat coeff_, names(matcol)`



## Regressionsergebnisse

Die Koeffizienten und Standardfehler des letzten Modells werden in `e()` gespeichert:
```{stata reg00,eval = F}
reg F518_SUF F200
```
```{stata reg01,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode zpalter, mv(9999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
}
reg F518_SUF F200
```


```{stata reg01b,eval = F}
mat l e(b)
```
```{stata reg01c,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode zpalter, mv(9999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
}
mat l e(b)
```

### Koeffizienten mit `_b` / `_se` aufrufen

Allerdings gibt es noch eine Abkürzung mit `_b[varname]` bzw. `_se[varname]`:

```{stata reg02, eval = F}
dis "Der Koeffizient für F200 ist " _b[F200]
dis "Der Standardfehler des Koeffizienten für F200 ist " _se[F200]
```
```{stata reg02b,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
reg F518_SUF F200
}
dis "Der Koeffizient für F200 ist " _b[F200]
dis "Der Standardfehler des Koeffizienten für F200 ist " _se[F200]
```

Wir können so auch vorhergesagte Werte berechnen - entweder für spezifische Werte:
```{stata reg03, eval= F}
dis _b[_cons] + 20 *_b[F200]
margins, at(F200 = 20)
```
```{stata reg03b, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
reg F518_SUF F200
}
dis _b[_cons] + 20 *_b[F200]
margins, at(F200 = 20) noatlegend
```

...oder für alle Beobachtungen:
```{stata reg04, eval= F}
gen pred_manual = _b[_cons] + F200 *_b[F200]
predict pred_auto, xb
gen diff=  pred_manual - pred_auto
su diff
```
```{stata reg04b, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
  gen pred_manual = _b[_cons] + F200 *_b[F200]
  predict pred_auto, xb
  gen diff=  pred_manual - pred_auto
}
su diff
```


### Komplette Regressionstabelle


```{stata regtab1, eval = F}
reg F518_SUF F200
matlist r(table) 
```
```{stata regtab2, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
}
matlist r(table) 
```


## `frame`



## `statsby`

```{stata, eval = F}
statsby _b _se, by(Bula) noisily: ///
	regress F518_SUF c.F200##c.F200 i.m1202 i.S1
```




***

**[Übung 2](#retue2)**

***



## Übungen

### Übung {#retue1}

- Erstellen Sie eine Schleife, welche jeweils das Maximaleinkommen (basierend auf `F518_SUF`) für die Gemeindegrößenklassen (`gkpol`) anzeigt.
  + Schließen Sie mit `mvdecode F518_SUF, mv( 99998/ 99999)` missings aus
  + Wie kommen Sie an den Maximalwert für `F518_SUF`? Verwenden Sie bspw. `su` oder `tabstat` zusammen mit `return list`.
  + Erstellen Sie mit `display` eine aussagekräftige Ausgabe
  + Testen Sie Ihre Schleifenlogik mit einem `local`, um anschließend die Schleife "außen herumzubauen"
  + Welche Ausprägungen hat `gkpol` - wie können Sie diese automatisch in eine Schleife überführen?


- Sammeln Sie die Ergebnisse jetzt in einer `matrix` 
  - Erstellen Sie eine leere `matrix` mit der passenden Anzahl an Zeilen und Spalten
  - Kopieren Sie die oben erstellte Schleife und passen Sie diese so an, dass die Werte (zusätzlich zu Anzeige) in dieser `matrix` gesammelt werden. Stimmen die Werte?

- Passen Sie Ihre Schleife an, sodass für jeden Durchlauf ein `global gkX` erstellt wird, wobei `X` für die Ausprägung von `gkpol` steht und den entsprechenden Maximalwert von `F518_SUF` für die entsprechende Größenklasse enthält.

  
### Übung

nur bei N > 20

### Übung

+ save the coefficients in a separate data set
+ graph the educ and union coefficients against year


