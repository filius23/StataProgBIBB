# Regressionsergebnisse weiterverarbeiten {#regres}

```{r setup3, echo = F, message=F, warning = F}
if(Sys.getenv("USERNAME") == "Filser" ) .libPaths("D:/R-library4")  # set library
# stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
stataexe <- "C:/Program Files/Stata16/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
library(Statamarkdown)
library(kableExtra)
library(magrittr)
# library(tidyverse)
# library(ggthemes)
```


## `e()` und `r()` der Regressionsergebnisse

Die Koeffizienten und Standardfehler des letzten Modells werden in `e()` gespeichert:
```{stata reg00,eval = F}
reg F518_SUF F200
```
```{stata reg01,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode zpalter, mv(9999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
}
reg F518_SUF F200
```


```{stata reg01b,eval = F}
mat l e(b)
```
```{stata reg01c,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode zpalter, mv(9999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
}
mat l e(b)
```

### Koeffizienten mit `_b` / `_se` aufrufen

Allerdings gibt es noch eine Abkürzung mit `_b[varname]` bzw. `_se[varname]`:

```{stata reg02, eval = F}
dis "Der Koeffizient für F200 ist " _b[F200]
dis "Der Standardfehler des Koeffizienten für F200 ist " _se[F200]
```
```{stata reg02b,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
reg F518_SUF F200
}
dis "Der Koeffizient für F200 ist " _b[F200]
dis "Der Standardfehler des Koeffizienten für F200 ist " _se[F200]
```

Wir können so auch vorhergesagte Werte berechnen - entweder für spezifische Werte:
```{stata reg03, eval= F}
dis _b[_cons] + 20 *_b[F200]
margins, at(F200 = 20)
```
```{stata reg03b, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
mvdecode F518_SUF, mv( 99998/ 99999)
mvdecode F200, mv( 97/99)
mvdecode m1202, mv(-1)
reg F518_SUF F200
}
dis _b[_cons] + 20 *_b[F200]
margins, at(F200 = 20) noatlegend
```

...oder für alle Beobachtungen:
```{stata reg04, eval= F}
gen pred_manual = _b[_cons] + F200 *_b[F200]
predict pred_auto, xb
gen diff=  pred_manual - pred_auto
su diff
```
```{stata reg04b, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
  gen pred_manual = _b[_cons] + F200 *_b[F200]
  predict pred_auto, xb
  gen diff=  pred_manual - pred_auto
}
su diff
```


### Komplette Regressionstabelle

Die vollständige Regressionstabelle ist aber eine r-Class matrix:
```{stata regtab1, eval = F}
reg F518_SUF F200
matlist r(table) 
```
```{stata regtab2, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
}
mat list r(table) 
```

## Regressionstabellen als `matrix` speichern und anpassen

Mit `'` können wir die Regressionstabelle transponieren:
```{stata regmat, eval = F}
reg F518_SUF F200
mat C = r(table)'
mat l C
```
```{stata regmat2, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
  mat C = r(table)'
}
mat l C 
```

[rownumb](#crnumb) hilft, einen Koeffizienten zu suchen:
```{stata regmat3, eval = F}
mat C1 = C[rownumb(C,"F200"),1...]
mat l C1
```

```{stata regmat4, echo= F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF F200
  mat C = r(table)'
  mat C1 = C[rownumb(C,"F200"),1...]
}
mat l C1
```


## kategoriale UV

Der Koeffizientenname ist etwas komplizierterer Name bei kat. UVs:
```{stata katuv1,eval = F}
reg F518_SUF i.S1 F200
ereturn list
mat l r(table) 
dis "Der Koeffizient für S1 = weiblich ist " _b[2.S1]
```


```{stata katuv01,echo = F}
qui use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
quietly{
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF i.S1 F200
}
mat l r(table) 
dis "Der Koeffizient für S1 = weiblich ist " _b[2.S1]
```

Dies müssen wir auch bei der Suche nach einem Koeffizienten berücksichtigen:
```{stata katuv2,eval = F}
mat D = r(table)' // transponieren:
mat D2 = D[rownumb(D,"2.S1"),1...] // nur Koeffizient für S1 = 2
mat l D2
```

## Als Datensatz ablegen:

Auch hier können wir dann mit `xsvmat` die Matrix in einen Datensatz umformatieren:
```{stata regframe, eval = F}
cap frame drop regres1
xsvmat D2,  names(col) rownames(coef) frame(regres1)
frame change regres1

list, noobs clean // keine Info zum Modell...
```

```{stata list, eval = F}
 coef           b         se           t     pvalue          ll          ul      df       crit   eform  
1b.S1           0          .           .          .           .           .   14656   1.960126       0  
 2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0  
 F200    95.08006   3.203812    29.67717          0    88.80019    101.3599   14656   1.960126       0  
_cons    464.4218   125.9036    3.688709   .0002262    217.6349    711.2088   14656   1.960126       0  
```


## weitere Infos aus `e()`

In [`ereturn list`](#) oben sehen wir, dass `e(cmdline)` den `reg`-Befehl enthält:

```{stata elist, eval = F}
dis "`e(cmdline)'"
```

```{stata elistreg,echo = F}
quietly{
 use "D:\Datenspeicher\BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta", clear
  mvdecode zpalter, mv(9999)
  mvdecode F518_SUF, mv( 99998/ 99999)
  mvdecode F200, mv( 97/99)
  mvdecode m1202, mv(-1)
  reg F518_SUF i.S1 F200
}
dis "`e(cmdline)'"
```

Diese Information können wir als `global` mit in den Ergebnis-`frame` nehmen. `global`s bleiben nehmen in der Session erhalten, auch wenn wir zwischen `frame`s wechseln.

## `reg`-Loop

Um den Nutzen zu demonstrieren, erstellen wir eine Schleife, welche eine Reihe an Regressionsmodellen schätzt und bei jedem Durchlauf einen zusätzlichen Term hinzunimmt.
Wir interessieren uns aber nur, dafür wie sich der Koeffizient für das Geschlecht (S1 == 2) entwickelt mit jedem neuen Modell:

```{stata regloop0, eval = F}
local predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter // UV-Liste
local r = 1 // Zähler 
loc uv 		// uv rücksetzen (zur sicherheit)
foreach v of local predictors {
    local uv `uv' `v'
	qui regress F518_SUF `uv'
	mat D = r(table)'						// reg-tabelle transponieren & speichern 
	mat D2 = D[rownumb(D,"2.S1"),1...]		// Koeffizient für S1=2 behalten
	
	if (`r' == 1) mat R = D2 				// im ersten Durchlauf R erstellen
	if (`r' != 1) mat R = R\D2 				// danach: D2 an R anfügen
		
	loc ++r // Zähler + 1
}
mat l R
```


```{stata regloop01, eval = F}
R[6,9]
               b          se           t      pvalue          ll          ul          df        crit       eform
2.S1  -1431.8093   53.630001  -26.697917   8.52e-154  -1536.9298  -1326.6888       16633   1.9601066           0
2.S1  -628.91281   55.392637  -11.353726   9.461e-30  -737.48935  -520.33627       14656   1.9601259           0
2.S1   -661.6656   55.679749  -11.883416   2.034e-32  -770.80492  -552.52628       14655   1.9601259           0
2.S1  -664.94219   53.793012  -12.361126   6.336e-35  -770.38328  -559.50111       14633   1.9601261           0
2.S1  -700.71303   54.028438  -12.969337   2.975e-38  -806.61563  -594.81043       14552    1.960127           0
2.S1  -717.33567   54.061055  -13.268991   5.977e-40  -823.30221  -611.36914       14551    1.960127           0

```
Wie wissen wir jetzt, für was kontrolliert wurde?

Wir nutzen den Zähler, um ein `global` mit der Zählernummer zu erstellen und eine Zeile in die `matrix` einzufügen:
```{stata regloop1, eval = F}
local predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter
local r = 1 // Zähler 
loc uv 		// uv rücksetzen (zur sicherheit)
foreach v of local predictors {
    local uv `uv' `v'
	qui regress F518_SUF `uv'
	mat D = r(table)'						// reg-tabelle transponieren & speichern 
	mat D2 = D[rownumb(D,"2.S1"),1...]		// Koeffizient für S1=2 behalten
	
	mat M = `r'
	mat colname M = mod
	
	if (`r' == 1) mat R = D2 , M			// ,r -> zähler an Koeffizientzeile anfügen
	if (`r' != 1) mat R = R\(D2 , M)
	glo cmd`r' = "`e(cmdline)'"
	loc ++r // Zähler + 1
}
mat l R
```


```{stata regloop11, eval = F}
R[6,10]
               b          se           t      pvalue          ll          ul          df        crit       eform         mod
2.S1  -1431.8093   53.630001  -26.697917   8.52e-154  -1536.9298  -1326.6888       16633   1.9601066           0           1
2.S1  -628.91281   55.392637  -11.353726   9.461e-30  -737.48935  -520.33627       14656   1.9601259           0           2
2.S1   -661.6656   55.679749  -11.883416   2.034e-32  -770.80492  -552.52628       14655   1.9601259           0           3
2.S1  -664.94219   53.793012  -12.361126   6.336e-35  -770.38328  -559.50111       14633   1.9601261           0           4
2.S1  -700.71303   54.028438  -12.969337   2.975e-38  -806.61563  -594.81043       14552    1.960127           0           5
2.S1  -717.33567   54.061055  -13.268991   5.977e-40  -823.30221  -611.36914       14551    1.960127           0           6
```

Diese `matrix` R schicken wir jetzt in einen `frame`:
```{stata regloop2, eval = F}
cap frame drop rmods
xsvmat R,  names(col) rownames(coef) frame(rmods)
frame change rmods

list, noobs clean
```


```{stata regloop02, eval = F}
coef           b         se           t     pvalue          ll          ul      df       crit   eform   mod  
2.S1   -1431.809      53.63   -26.69792          0    -1536.93   -1326.689   16633   1.960107       0     1  
2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0     2  
2.S1   -661.6656   55.67975   -11.88342   2.03e-32   -770.8049   -552.5263   14655   1.960126       0     3  
2.S1   -664.9422   53.79301   -12.36113   6.34e-35   -770.3833   -559.5011   14633   1.960126       0     4  
2.S1    -700.713   54.02844   -12.96934   2.97e-38   -806.6156   -594.8104   14552   1.960127       0     5  
2.S1   -717.3357   54.06105   -13.26899          0   -823.3022   -611.3691   14551   1.960127       0     6  
```

Jetzt wissen zwar schon mal, aus welchem Modell der Koeffizient jeweils kommt (basierend auf `mod`). 
Eigentlich würden das aber gerne labeln.
Dazu können wir jetzt auf die `globals` zurückgreifen - mit [`all globals`](#allglo) können wir nach ihnen suchen:
```{stata regloop3, eval = F}
global allglo:  all globals "cmd*"
mac l allglo
allglo:         cmd6 cmd5 cmd4 cmd3 cmd2 cmd1
```

```{stata regloop03, eval = F}
mac l cmd1
cmd1:           regress F518_SUF i.S1
```

Jetzt können wir mit einer Schleife die Spalte `mod` labeln. 
Mit `label define ....` können Wertelabels erstellt werden - mit der Option `,modify` können wir das auch schrittweise verändern. 
Außerdem können wir einen kleinen Trick nutzen, um innerhalb der Schleife auf das `global` mit einer bestimmten Zahl zuzugreifen: 
```{stata regloop4, eval = F}
levelsof mod, loc(mnrs)
  foreach m of local mnrs {
  	lab def mod_lab `m' "${cmd`m'}", modify // value label verändern 
  }
lab val mod mod_lab

list, noobs clean
```



## Übungen


+ save the coefficients in a separate data set
+ graph the educ and union coefficients against year






## Anhang

### `statsby`

```{stata, eval = F}
statsby _b _se, by(Bula) noisily: ///
	regress F518_SUF c.F200##c.F200 i.m1202 i.S1
```


### weitere `matrix`-Befehle

Wir können auch Rechnungen einfügen:
```{stata mat04}
matrix X1 = (1+1, 2*3/4 \ 5/2, 3)
mat l X1 
```

#### Teilmatrizen

```{stata tm01}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
mat l X1
```


Wir können aus diesen Matrizen auch Teilbereiche auswählen:
```{stata tm02, eval = F}
matrix newmat = oldmat[Zeile(nbereich), Spalte(nbereich)]
```
Zeilenbereich und Spaltenbereich können einzelne Zahlen oder Bereiche mit durch zwei Punkte getrennten Start- und Endpositionen sein.

Matrix B erstellen, welche die Zeile 2-4 und die Spalte 1-5 von X1 enthält:
```{stata tm03, eval = F}
matrix B = X1[2..4,1..5]
mat l B
mat l X1
```
```{stata tm04, echo = F}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
matrix B = X1[2..4,1..5]
mat l B
mat l X1
```

Um alle Zeilen nach der zweiten Zeile zu übernehmen, verwenden wir drei Punkte:
```{stata tm05, eval = F}
matrix C = X1[2...,1..5]
mat l C
mat l X1
```

```{stata tm06, echo = F}
qui mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
matrix C = X1[2...,1..5]
mat l C
mat l X1
```

#### Spalten/Zeilen auswählen

B1 enthält Spalte 1 und 3 aus `X1`:
```{stata tm04b, eval = F}
mat B1 = X1[1...,1],X1[1...,3]
mat l B1
mat l X1
```

```{stata tm04c, echo = F}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
mat B1 = X1[1...,1],X1[1...,3]
mat l B1
mat l X1
```

B2 enthält Zeile 1 und 3 aus `X1`:
```{stata tm04d, eval = F}
mat B2 = X1[1,1...] \ X1[4,1...]
mat l B2
mat l X1
```

```{stata tm04e, echo = F}
mat X1 = (1,2,3,4,5 \ 6,7,8,9,10 \ 0,-1,-2,-3,-5 \ -6,-7,-8,-9,-10)
mat B2 = X1[1,1...] \ X1[4,1...]
mat l B2
mat l X1
```

<!-- * https://thedatamonkey.blogspot.com/2011/01/stata-matrices.html -->

#### Namensbasierte Auswahl {#crnumb}

Hier helfen `rownumb` und `colnumb`

```{stata namesel}
mat X1 = (1,2,3 \ 8,9,10 )
mat colname X1 = var1 var2 var3
mat rowname X1 = set1 set2

mat X2 = X1[rownumb(X1,"set1"),1...]
mat l X2
```


```{stata namesel2, eval = F}
mat X3 = X1[1...,colnumb(X1,"var2")]
mat l X3
```


```{stata namesel3, echo = F}
mat X1 = (1,2,3 \ 8,9,10 )
mat colname X1 = var1 var2 var3
mat rowname X1 = set1 set2
mat X3 = X1[1...,colnumb(X1,"var2")]
mat l X3
```
