[["macro.html", "1 Macros 1.1 = macht einen Unterschied 1.2 local und global sind getrennte Welten 1.3 Macros mit Text 1.4 Dateipfade 1.5 Bereits definierte Macros 1.6 Wenn nicht if, dann else 1.7 Schleifen: foreach &amp; forvalues 1.8 Übungen 1.9 Windows Dateipfade mit macros 1.10 Details", " 1 Macros Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]: glo x = 1 loc y = 2 dis ${x} dis `y&#39; 1 2 oder mit macro list, hier sind die macros aber ohne punctuation (also $ oder `') glo x = 1 loc y = 2 mac list x mac list _y x: 1 _y: 2 Der Unterschied besteht vor allem darin, dass local macros lokal für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Letztlich können wir jede Instanz, in der wir mehrere Zeilen eines DoFiles ausführen als Programm ansehen. globals können wir später nochmal aufrufen, locals nicht: mac list xg xg: 1 mac list _xl r(111); end of do-file r(111); 1.1 = macht einen Unterschied In der Regel können wir auch einfach glo glname Wert bzw. loc locname Wert statt glo glname = Wert bzw. loc locname = Wert angeben. Allerdings ist hier etwas Vorsicht geboten, denn das = ist entscheidend ob die Rechnung abgelegt wird oder das Ergebnis (Stichwort evaluation): Im Ergebnis sehen wir hier beides Mal das gleiche: local m1 2+2 display `m1&#39; 4 local m2 = 2+2 display `m2&#39; 4 Aber wenn wir uns mit mac list die abgelegten Infos ansehen, dann sehen wir den entscheidenden Unterschied: mac list _m1 _m2 _m1: 2+2 _m2: 4 Wenn wir nämlich mit m1 und m2 weiterrechnen, da kann folgendes passieren: local m1 2+2 display `m1&#39;*4 10 local m2 = 2+2 display `m2&#39;*4 16 Denn \\(2+2*4\\neq4*4\\) 1.2 local und global sind getrennte Welten Geht, aber ist nicht zu empfehlen: glo yx = 1 loc yx = 2 mac list yx mac list _yx yx: 1 _yx: 2 1.3 Macros mit Text Wir können macros zu Texten zusammenbauen: glo t1 &quot;Hallo&quot; glo t2 &quot; zusammen&quot; glo t3 &quot;! :-)&quot; glo t4 = &quot;${t1}${t2}${t3}&quot; dis &quot;${t4}&quot; mac list t1 t2 t3 t4 Hallo zusammen! :-) t1: Hallo t2: zusammen t3: ! :-) t4: Hallo zusammen! :-) 1.4 Dateipfade Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden: glo pfad &quot;D:\\Projekt\\daten\\BIBB_BAuA&quot; // wo liegt der Datensatz? use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden: glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. Wir lernen gleich noch eine Möglichkeit kennen, das auch direkt mit zu lösen mit dem Usernamen der verwendeten PCs. use &quot;${data}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Bei Dateipfaden ist jedoch \\ beim Zusammenbauen mit macros manchmal problematisch). Ggf. hilft hier / statt \\ zu verwenden. 1.5 Bereits definierte Macros Mit mac list bekommen wir auch einige von Stata bereits vorgegebenen Macros angezeigt. mac list Zwei sehr nützliche sind dabei $S_DATE $S_TIME - das aktuelle Datum und die aktuelle Zeit: dis &quot;$S_DATE&quot; dis &quot;$S_TIME&quot; 1 Dec 2021 12:44:22 Diese können wir beispielsweise am Anfang und Ende eines LogFiles einblenden, um Start- und Endzeit zu dokumentieren: log using &quot;${log}/logfile.txt&quot;, t replace dis &quot;Start: $S_DATE um $S_TIME&quot; use .... . . . . . . dis &quot;Ende: $S_DATE um $S_TIME&quot; log close Außerdem gibt es einige locals mit nützlichen Infos: dis &quot;`c(username)&#39;&quot; dis &quot;`c(machine_type)&#39;&quot; dis &quot;`c(os)&#39;&quot; Filser PC (64-bit x86-64) Windows Weitere system parameters and settings unter help creturn bspw.: c(changed) returns a numeric scalar equal to 0 if the dataset in memory has not changed since it was last saved and 1 otherwise. c(filename) returns a string containing the filename last specified with a use or save, such as \"C:\\Data\\auto.dta\". c(filedate) returns a string containing the date and time the file in c(filename) was last saved, such as 7 Jul 2016 13:51. 1.5.1 if Mit if (local== \"...\") können wir macros abgleichen, um Befehle nur unter bestimmten Bedingungen auszuführen: if (&quot;`c(username)&#39;&quot; == &quot;Filser&quot;) display &quot;Du bist Filser&quot; if (&quot;`c(username)&#39;&quot; != &quot;Fischer&quot;) display &quot;Du bist nicht Fischer&quot; Das können wir für den Fall von eben mit mehreren Nutzern nutzen: if (&quot;`c(username)&#39;&quot; == &quot;Alex&quot;) glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? if (&quot;`c(username)&#39;&quot; == &quot;Micha&quot;) glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes 1.5.2 Macros als Variablennamen und Befehle Auch so etwas ist möglich: local n 200 su F`n&#39; Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- F200 | 17,953 36.24272 14.03048 1 99 Ein macro kann auch ein Programm sein: loc t tab `t&#39; zpalter Mobilfunkin | terview | Freq. Percent Cum. ------------+----------------------------------- Festnetz | 14,008 70.00 70.00 Mobilfunk | 6,004 30.00 100.00 ------------+----------------------------------- Total | 20,012 100.00 1.5.3 globals durchsuchen Mit Hilfe sog. Wildcards können wir Zeichen offen lassen: ? ersetzt ein Zeichen * mehrere oder keines glo x1 = 2 glo x2 &quot;das ist x2&quot; glo x 291 global allglo: all globals &quot;x*&quot; mac l allglo allglo: x x2 x1 Hier haben wir auch schon die dritte Form der macro Definition kennengelernt, die sog. extended macro function, welche auf : folgt. Hier also all globals, im Laufe dieses Kurses werden wir noch zahlreiche dieser Funktionen kennenlernen. Übung 1 1.6 Wenn nicht if, dann else Mit if haben wir die Möglichkeiten aber noch nicht ausgeschöpft - aus help if: if `n&#39;==1 { local word &quot;one&quot; } else if `n&#39;==2 { local word &quot;two&quot; } else if `n&#39;==3 { local word &quot;three&quot; } else { local word &quot;big&quot; } display &quot;`word&#39;&quot; Mit exit (help exit_program) können wir Stata zu einer Unterbrechung bringen: More generally, exit causes Stata to terminate the current process and returns control to the calling process. if &quot;`c(username)&#39;&quot; == &quot;Alex&quot; { glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? } else if &quot;`c(username)&#39;&quot; == &quot;Micha&quot; { glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? } else { display as error &quot;Hier fehlt der passende Pfad&quot; exit } Hier fehlt der passende Pfad end of do-file 1.7 Schleifen: foreach &amp; forvalues Schleifen helfen uns das DRY (Dont repeat yourself) Prinzip umzusetzen. Ein vereinfachtes Syntaxdiagramm der foreach-Schleife sieht so aus: foreach lname listtype list { Befehle } lname steht dabei für ein local macro. Wir können unterschiedliche Typen von foreach-Listen verwenden:  of varlist: Variablenlisten  of newlist: neue Variablen  of numlist: Nummernlisten - bspw. (0(1)5) \\(\\Rightarrow\\) 1 bis 5 in Schritten von 1  in: beliebige Listen von Buchstaben, Zahlen oder Wörtern (durch Leerzeichen getrennt) foreach n of numlist 1/3 6(1)9 { dis &quot;`n&#39;&quot; } 1 2 3 6 7 8 9 foreach n of numlist 6 4: -4 { dis &quot;`n&#39;&quot; } 6 4 2 0 -2 -4 Mit ferest() können wir uns die noch übrigen Werte in der Liste anzeigen lassen: foreach n of numlist 1(1)5 { dis &quot;`n&#39;&quot; dis &quot;Es kommen noch: `ferest()&#39;&quot; } 1 Es kommen noch: 2 3 4 5 2 Es kommen noch: 3 4 5 3 Es kommen noch: 4 5 4 Es kommen noch: 5 5 Es kommen noch: 1.7.1 Weitere Schleifentypen Es gibt außerdem forvalues: forvalues lname=range { Befehle } forvalues-Schleife ist eine foreach-Schleife mit numlist. Aber: Die foreach-Schleife mit einer numlist funktioniert nicht mit einer beliebig hohen Anzahl von Ziffern. In der forvalues-Schleife gibt es keine Beschränkung. Außerdem ist forvalues-Schleife schneller im Abarbeiten von Nummernlisten. Und dann gibt es noch die while-Schleife: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc i = `i&#39; + 1 } 1 2 3 4 5 Eine Besonderheit bei locals ist, dass wir mit loc ++i den Wert um 1 erhöhen können. Somit führt folgende Syntax zum gleichen Ergebnis: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc ++i } 1.7.2 Anwendung foreach v of numlist 19(5)35 { display &quot;Alter bis `v&#39;&quot; tab S1 if zpalter &lt;= `v&#39; } Alter bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 373 65.10 65.10 weiblich | 200 34.90 100.00 ------------+----------------------------------- Total | 573 100.00 Alter bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 991 60.46 60.46 weiblich | 648 39.54 100.00 ------------+----------------------------------- Total | 1,639 100.00 Alter bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 1,984 59.03 59.03 weiblich | 1,377 40.97 100.00 ------------+----------------------------------- Total | 3,361 100.00 oder mit inrange(), um lediglich die 5-Jahresaltersgruppe anzuzeigen: foreach v of numlist 19(5)35 { display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; tab S1 if inrange(zpalter,`v&#39;-4, `v&#39;) *su zpalter if inrange(zpalter,`v&#39;-4, `v&#39;) } Alter 15 bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter 20 bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 332 64.84 64.84 weiblich | 180 35.16 100.00 ------------+----------------------------------- Total | 512 100.00 Alter 25 bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 618 57.97 57.97 weiblich | 448 42.03 100.00 ------------+----------------------------------- Total | 1,066 100.00 Alter 30 bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 993 57.67 57.67 weiblich | 729 42.33 100.00 ------------+----------------------------------- Total | 1,722 100.00 1.7.3 Schleifen aufbauen Einfache Schleife mit if/else: ist Zahl gerade oder ungerade? loc n = 5 if trunc(`n&#39;/2) == `n&#39;/2 display &quot;ja&quot; if trunc(`n&#39;/2) != `n&#39;/2 display &quot;nein&quot; loc n = 5 dis mod(`n&#39;,2) forvalues n = 1/10 { if mod(`n&#39;,2) == 0 dis &quot;`n&#39; ist gerade&quot; if mod(`n&#39;,2) == 1 dis &quot;`n&#39; ist ungerade&quot; } forvalues n = 1/10 { if mod(`n&#39;,2) == 0 { dis &quot;`n&#39; ist gerade&quot; } else if mod(`n&#39;,2) == 1 { dis &quot;`n&#39; ist ungerade&quot; } else { display as error &quot;hier ging was schief&quot; exit } } mod() ist der Modulo-Operator ist Stata - es wird der Rest berechnet Übung 2 Variablen &amp; value labels anzeigen/bearbeiten Creating interaction variables Fitting models with alternative measures of education Recoding multiple variables the same way Creating a macro that holds accumulated information Retrieving information returned by Stata 1.8 Übungen 1.8.1 Übung Pfad zusammenbauen für use: Erstellen Sie den Pfad für den use-Befehl schrittweise und unter Berücksichtigung ihres Usernamens. ggf. Dateiverzeichnis einrichten mit Ordner log, prog und data (gerne auch mehr oder andere Namen) Legen Sie die Erwerbstätigenbefragung 2018 in den data-Ordner (oder dessen Äquivalent) Wie ist der Username auf Ihrem Gerät? Verwenden Sie ein if-Statement, um den Dateipfad zu erstellen 1.8.2 Übung: FizzBuzz-Challenge Fizz Buzz wird/wurde ein Screening-Instrument für Programmierer*innen verwendet. Fizz Buzz ist ein Kinderlernspiel, bei dem die Kinder üblicherweise im Kreis sitzen und reihum laut von eins aufwärts zählen. Allerdings gibt es zwei Regeln: Dabei müssen alle Zahlen, die durch drei teilbar sind, durch das Wort Fizz ersetzt werden und alle Zahlen, die durch fünf teilbar sind, durch das Wort Buzz. Wenn eine Zahl durch drei und fünf teilbar ist, dann wird Fizz Buzz gerufen. if &amp; else für Schleife 1-10: bei geraden Zahlen gerade und bei ungeraden Zahlen ungerade anzeigen Die 1.9 Windows Dateipfade mit macros Aus der Stata-Doku zu macros: Stata uses the  character to tell its parser not to expand macros. Windows uses the  character as the directory path separator. Mostly, there is no problem using a  in a filename. However, if you are writing a program that contains a Windows path in macro path and a filename in fname, do not assemble the final result as path\\fname because Stata will interpret the  as an instruction to not expand fname. Instead, assemble the final result as path/fname. Stata understands / as a directory separator on all platforms. \\(\\Rightarrow\\) 1.10 Details 1.10.1 local x entspricht global _x Theoretisch kann man auch mit global _x einen local x erzeugen: local x = 2 global _x = 3 dis local i=1 global _i=1 Damit könnte man auch so alle locals auflisten: glo x1 = 2 glo x2 &quot;das ist x2&quot; glo x 291 global allglo: all globals &quot;_x*&quot; mac l allglo global a &quot;myvar&quot; gen $a = oldvar gen myvar = oldvar gen a = oldvar gen a = oldvar local a &quot;myvar&quot; gen a = oldvar gen myvar = oldvar gen a = oldvar gen a = oldvar global a &quot;newvar&quot; global i = 2 gen $a$i = oldvar gen newvar2 = oldvar local a &quot;newvar&quot; local i = 2 gen ai = oldvar gen newvar2 = oldvar global b1 &quot;newvar&quot; global i=1 gen ${b$i} = oldvar gen newvar = oldvar local b1 &quot;newvar&quot; local i=1 gen bi = oldvar gen newvar = oldvar global b1 &quot;newvar&quot; global a &quot;b&quot; global i = 1 gen ${$a$i} = oldvar gen newvar = oldvar local b1 &quot;newvar&quot; local a &quot;b&quot; local i = 1 gen ai = oldvar gen newvar = oldvar "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
