[["labmacro.html", "4 Label- und Variablenfunktionen 4.1 Stringfunktionen 4.2 Arbeiten mit Regular Expressions 4.3 Label bearbeiten 4.4 Abgleiche 4.5 wo kommt überall -4 vor? 4.6 Übungen 4.7 Anhang", " 4 Label- und Variablenfunktionen Inspiriert von der UCLA einige Beispielstrings: clear all input str60 add &quot;4905 Lakeway Drive, College Station, Texas 77845 USA&quot; &quot;673 Jasmine Street, Los Angeles, CA 90024&quot; &quot;2376 First street, San Diego, CA 90126&quot; &quot;6 West Central St, Tempe AZ 80068&quot; &quot;1234 Main St. Cambridge, MA 01238-1234&quot; &quot;Robert-Schuman-Platz 3, 53175 Bonn GERMANY&quot; &quot;Regensburger Straße 100, 90478 Nürnberg Germany&quot; &quot; Ammerländer Heerstraße 114-118, 26129 Oldenburg GERMANY &quot; end 4.1 Stringfunktionen help string functions gen x1 = substr(add,5,10) // substring von add -&gt; Zeichen 5-10 gen x2 = wordcount(add) // Worte zählen gen x3 = word(add,5) // 5. Wort gen x4 = upper(add) // alles groß gen x5 = lower(add) // alles klein gen x6 = proper(add) // jeweiles erster Buchstabe eines Wortes groß gen x7 = trim(add) // Leerzeichen am Ende und Beginn raus gen x8 = strlen(add) // Anzahl der Zeichen in add Allerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit usubstr, ustrupper(), ustrlower() usw. - mehr dazu jeweils in der Hilfe. Der Weg zur passenden regex string-Funktion ist leider oft von vielen Versuchen begleitet, am einfachsten testet man mit display. So zeigt sich hier bspw., dass proper() hier ß und ü als Wortende/-beginn (mis-)versteht: display proper(&quot;Regensburger Straße 100, 90478 nüRnberg germany&quot;) Regensburger StraßE 100, 90478 NüRnberg Germany in der Hilfe finden wir ustrtitle: display ustrtitle(&quot;Regensburger Straße 100, 90478 nüRnberg germany&quot;) Regensburger Straße 100, 90478 Nürnberg Germany Hier wenig hilfreich, aber häufig eine gute Abkürzung: split split add, parse(&quot; &quot;) gen(t) Übung Tipp: real() ist deutlich schneller und unkomplizierter als destring clear all input str1 x1 &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;23&quot; &quot;21&quot; &quot;2&quot; &quot;--&quot; &quot;2&quot; end gen num = real(x1) list destring(x1), gen(num2) x1 1. &quot;2&quot; 2. &quot;3&quot; 3. &quot;5&quot; 4. &quot;23&quot; 5. &quot;21&quot; 6. &quot;2&quot; 7. &quot;--&quot; 8. &quot;2&quot; 9. end (1 missing value generated) +----------+ | x1 num | |----------| 1. | 2 2 | 2. | 3 3 | 3. | 5 5 | 4. | 2 2 | 5. | 2 2 | |----------| 6. | 2 2 | 7. | - . | 8. | 2 2 | +----------+ x1: contains nonnumeric characters; no generate 4.2 Arbeiten mit Regular Expressions regular expressions oder regex sind eine flexible Methode, strings (also Textinhalte) zu durchsuchen. Dabei suchen wir nach Mustern anstelle eines exakten matchings. In Stata können wir regex für Variablen, aber auch für macros und Labels verwenden. regex sind aber nicht immer die (einfachste) Lösung und oft werden die Befehle sehr unübersichtlich. Daher hier nur ein kurzer Überblick. Die drei Hauptfunktionen in Stata finden wir unter help regex: regexm(s,re) allows you to search for the string described in your regular expressions. It evaluates to 1 if the string matches the expression. regexs(n) returns the nth substring within an expression matched by regexm (hence, regexm must always be run before regexs). regexr(s1,re,s2) searches for re within the string (s1) and replaces the matching portion with a new string (s2). Allerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit ustrregexm, ustrregexs, ustrregexrf und ustrregexra. Auf die konzentrieren wir uns hier. 4.2.1 regex (Grund-)Regeln regex basieren auf einer Reihe an Zeichen, mit Hilfe derer wir strings durchsuchen können: \\d matcht eine Zahl \\w matcht alphanumeric characters (Buchstaben &amp; Zahlen) \\s matcht ein Leerzeichen ^ matche Ausdruck am Anfang des strings $ matche Ausdruck am Ende des strings - lässt eine range zu: a-z, 0-9, 5-8, F-M etc. . bedeutet matche irgendein Zeichen \\ ist ein escape character für Zeichen, die ansonsten als regex-Operator verstanden würden | oder-Operator [] use in matching, such as [a-zA-Z0-9] for all alphanumeric characters () darin angegebene Werte können wir mit ustrregexs extrahieren * matche 0 oder öfter für den vorhergehenden Ausdruck + matche 1 oder öfter für den vorhergehenden Ausdruck 4.2.2 Beispiele Inspiriert von der UCLA einige Beispielstrings: clear all input str60 add &quot;4905 Lakeway Drive, College Station, Texas 77845 USA&quot; &quot;673 Jasmine Street, Los Angeles, CA 90024&quot; &quot;2376 First street, San Diego, CA 90126&quot; &quot;6 West Central St, Tempe AZ 80068&quot; &quot;1234 Main St. Cambridge, MA 01238-1234&quot; &quot;Robert-Schuman-Platz 3, 53175 Bonn GERMANY&quot; &quot;Regensburger Straße 100, 90478 Nürnberg Germany&quot; &quot;Ammerländer Heerstraße 114-118, 26129 Oldenburg GERMANY&quot; end gen d = ustrregexm(add, &quot;GERMANY|Germany&quot;) Das m in ustrregexm steht für match. Mit ustrregexm können wir nach Zeichenketten suchen. Wenn sie gefunden wird, wird eine 1 zurückzugeben, andernfalls 0. Hier suchen wir nach entweder GERMANY oder Germany. Wir können aber auch den gefundenen Inhalt extrahieren. Bei Übereinstimmungen werden die matches gespeichert, darauf können wir mit ustrregexs zurückgreifen: gen d2 = ustrregexs(0) if ustrregexm(add, &quot;GERMANY|Germany&quot;) s steht für subexpressions (oder tokens). Token 0 enthält alle übereinstimmenden Muster. Wird eine Zeichenkette mehrfach gefunden, dann enthält Token 0 alle Übereinstimmungen, Token 1 die erste, Token 2 die zweite und so weiter. ustrregexrf und ustrregexra helfen uns schließlich, Inhalte zu ersetzen. rf bzw. ra stehen dabei für replace first bzw. replace all. ustrregexrf ersetzt also nur den ersten match, ustrregexra hingegen alle. Basierend auf den Regeln von oben ergeben diese beiden Befehle unterschiedliche Ergebnisse: gen s1 = ustrregexra(add, &quot;street&quot;, &quot;!&quot;) gen s2 = ustrregexra(add, &quot;[street]&quot;, &quot;!&quot;) In s1 wurden alle matches street gelöscht und durch ! ersetzt. In s2 wurden alle matches von s,t,r,e und t gelöscht und durch ! ersetzt. Weitere Beispiele für ersetzen mit regex-Regelausdrücken - siehe DoFile: gen z1 = ustrregexra(add, &quot;\\w&quot;, &quot;&quot;) // alle alphanumeric ersetzen gen z2 = ustrregexra(add, &quot;\\W&quot;, &quot;&quot;) // alle nicht-alphanumeric ersetzen gen z3 = ustrregexra(add, &quot;\\d&quot;, &quot;&quot;) // alle Zahlen ersetzen gen z4 = ustrregexra(add, &quot;\\D&quot;, &quot;&quot;) // alle nicht-Zahlen ersetzen gen z5 = ustrregexra(add, &quot;.+,&quot;, &quot;&quot;) // alles vor dem Komma ersetzen gen z6 = ustrregexra(add, &quot;,.+&quot;, &quot;&quot;) // alles nach dem Komma ersetzen Nach Zahlen suchen: gen r1 = ustrregexs(0) if ustrregexm(add, &quot;\\d&quot;) // Zahl gen r2 = ustrregexs(0) if ustrregexm(add, &quot;\\d+&quot;) // Zahlenfolge gen r3 = ustrregexs(0) if ustrregexm(add, &quot;(\\d{5})&quot;) // 5-stellige Zahl gen r4 = ustrregexs(0) if ustrregexm(add, &quot;^(\\d+)&quot;) // Zahlenfolge am Anfang gen r5 = ustrregexs(0) if ustrregexm(add, &quot;(\\d+).*(\\d+)&quot;) // Zahlenfolgen und alles was dazwischen kommt gen r6 = ustrregexs(0) if ustrregexm(r5, &quot;(\\d+)$&quot;) // Zahlenfolge am Ende -&gt; aus r5! 4.2.3 Weiterführende Links Hier findet sich ein sehr gutes Cheatsheet zu den gebräuchlichsten regex. Das zugehörige Tutorial ist ebenfalls sehr lesenswert. Die Übersicht der UCLA bietet auch nochmal einige Hinweise - allerdings auf Basis der ASCII-basierten Befehle. Stata Hilfe Hier findet sich ein weiteres hilfreiches Tutorial Übung 4.3 Label bearbeiten Um Informationen zu Variablen &amp; Labels abzurufen, stehen eine ganze Reihe an extended macro functions zur Verfügung: loc v m1202 local vartype: type `v&#39; // Variablen &quot;storage type&quot; (byte etc) local varlab: variable label `v&#39; // variable label local vallabname: value label `v&#39; // Name des value label local vallab1 : label (`v&#39;) 1 // Value label für Wert = 1 Die so erstellten locals können wir dann in der bekannten Methode wieder darstellen: di &quot;`vartype&#39;&quot; // display local &quot;vartype&quot; di &quot;`varlab&#39;&quot; // display local &quot;varlabel&quot; di &quot;`vallabname&#39;&quot; // display local &quot;valuelabname&quot; di &quot;`vallab1&#39;&quot; // display local &quot;valuelab1&quot; Wir können die Labels und Eigenschaften von `v auch in einem Schritt anzeigen lassen, die Syntax sieht aber etwas eigenwillig aus: loc v m1202 di &quot;`: type `v&#39;&#39;&quot; // &quot;storage type&quot; (byte etc) der Variable di &quot;`: variable label `v&#39;&#39;&quot; // variable label di &quot;`: value label `v&#39;&#39;&quot; // Name des value label di &quot;`: label (`v&#39;) 1&#39;&quot; // Value label für Wert = 1 Damit können wir bspw. ein Variable Label kürzen: local longlabel: var label m1202 // variable label für variable m1202 suchen local shortlabel = substr(&quot;`longlabel&#39;&quot;,1,10) // verändern mit string Funktion label var m1202 &quot;`shortlabel&#39;&quot; // anwenden Um an die Value Labels zu kommen, braucht es etwas mehr: local lblname: value label m1202 // value labels für variable m1202 suchen cap label drop `lblname&#39;_n //neuen namen droppen zur Sicherheit label copy `lblname&#39; `lblname&#39;_n // value labelbook kopieren local lab1: label (m1202) 2 // value label für Wert = 2 aufrufen loc lab2 = upper(&quot;`lab1&#39;&quot;) // dieses value labels verändern label define `lblname&#39;_n `lvl&#39; &quot;`lab2&#39;&quot;, modify // in neues value labelbook einfügen labelbook `lblname&#39; `lblname&#39;_n // vergleich alt vs neu Mit label copy oldname newname, local lblname: value label var und local lab1: label (var) level können wir auch value-Labels bearbeiten: loc v m1202 local lblname: value label `v&#39; // value label aufrufen cap label drop `lblname&#39;_n // neuen Namen zur Sicherheit droppen label copy `lblname&#39; `lblname&#39;_n // kopieren levelsof `v&#39;, loc(x) // Werte für die Variable aufrufen foreach lvl of local x { local lab1: label (`v&#39;) `lvl&#39; // Value label Variable v bei Level lvl loc lab2 = substr(&quot;`lab1&#39;&quot;,1,8) // kürzen label define `lblname&#39;_n `lvl&#39; &quot;`lab2&#39;&quot;, modify // im neuen value label ändern } lab val `v&#39; `lblname&#39;_n // anwenden Übung 2 4.4 Abgleiche Existiert eine Variable? capture confirm variable lm02 if !_rc dis &quot;ja&quot; if _rc dis &quot;nein&quot; Ist variable numerisch? capture confirm numeric variable az if !_rc dis &quot;ja&quot; if _rc dis &quot;nein&quot; ja help data_types 4.5 wo kommt überall -4 vor? quietly ds local varlist1 `r(varlist)&#39; *display &quot;`varlist1&#39;&quot; foreach v of varlist1 { qui count if `v&#39; == -4 if r(N) &gt; 0 display &quot;`v&#39;&quot; } Übung 4.6 Übungen 4.6.1 Übung Verwenden Sie mit input die Adressdaten von oben Wie kommen Sie jeweils an das vorletzte Wort aus der Adressliste? Extrahieren Sie die zehn letzten Zeichen aus add, aber lassen die drei letzten Zeichen weg. (Zeichen 10 bis 4 von hinten her gezählt). 4.6.2 Übung Laden Sie den regex.dta: use \"https://github.com/filius23/StataProgBIBB/raw/main/docs/regex1.dta\", clear und teilen Sie die Informationen aus address in 4 Variablen auf: Hausnummer (erste Zahl), Straße, PLZ, Region Wandeln Sie alle Einträge in Großbuchstaben um Verwenden Sie split, um zwischen Adresse und PLZ &amp; Ort zu trennen Wie können Sie jetzt die Zahlen vom Text trennen? Löschen Sie ggf. Leerzeichen zu Beginn und am Ende der Variablen 4.6.3 Übung Laden Sie der Erwerbstätigenbefragung Kürzen die die variable labels für alle Variablen mit wissensintensiver Beruf im Label (d *wib*) Ersetzen Sie wissensintensiver Beruf in den variable labels mit wib. Spielen Sie die Routine erst für eine Variable durch: welche Label-Befehle brauchen Sie? Denken Sie an foreach ... of varlist und die Möglichkeit, wildcards zu verwenden. Alternativ hilft evtl. auch ds mit Wildcards Bearbeiten Sie das value label für nuts2 - nutzen Sie dafür die regex und string-Funktionen von oben Löschen Sie Statistische aus den den value labels und ersetzen Sie Direktionsbezirk durch Bezirk Kehren Sie die Codierung vom m1202 um: gen m1202_n = 10 - m1202 und passen Sie die value labels entsprechend an die neue Codierung an. Tipp: auch die value labels müssen dann jeweils 10 - x genommen werden. Für alle, die schon fertig sind: Wie könnten Sie automatisiert den Variable label für die Muttersprachenvariablen kürzen, sodass statt Muttersprache: nur noch MSpr im label steht? 4.6.4 Übung In welchen Variablen aus der Erwerbstätigenbefragung kommt der der Wert -9 vor? Füttern Sie diese Information in mvdecode, um die Missings zu überschreiben. Sammeln Sie die Information, welche Variablen -9 enthalten (Stichwort rekursive macro-Definition) Erstellen Sie einen mvdecode-Befehle, welcher die Information aufnimmt und in allen gefundenen Variablen -9 durch . ersetzt. 4.7 Anhang Variablen mit bestimmten Eigenschaften identifizieren in ein macro ds, has(type byte) loc bytevars `r(varlist)&#39; foreach v of local bytevars { rename `v&#39; b_`v&#39; } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
