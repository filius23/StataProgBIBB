[["macro.html", "1 Macros 1.1 = macht einen Unterschied 1.2 local und global sind getrennte Welten 1.3 Macros mit Text 1.4 Dateipfade 1.5 Bereits definierte Macros 1.6 Wenn nicht if, dann else 1.7 Schleifen: foreach &amp; forvalues 1.8 Übungen 1.9 Anhang", " 1 Macros Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]: glo x = 1 loc y = 2 dis ${x} dis `y&#39; 1 2 oder mit macro list, hier sind die macros aber ohne punctuation (also $ oder `') glo x = 1 loc y = 2 mac list x mac list _y x: 1 _y: 2 Der Unterschied besteht vor allem darin, dass local macros lokal für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Letztlich können wir jede Instanz, in der wir mehrere Zeilen eines DoFiles ausführen als Programm ansehen. globals können wir später nochmal aufrufen, locals nicht: mac list xg xg: 1 mac list _xl r(111); end of do-file r(111); 1.1 = macht einen Unterschied In der Regel können wir auch einfach glo glname Wert bzw. loc locname Wert statt glo glname = Wert bzw. loc locname = Wert angeben. Allerdings ist hier etwas Vorsicht geboten, denn das = ist entscheidend ob die Rechnung abgelegt wird oder das Ergebnis (Stichwort evaluation): + Mit = : der Ausdruck wird evaluated + Ohne = : der Ausdruck wird aliased Im Ergebnis sehen wir hier beides Mal das gleiche: local m1 2+2 display `m1&#39; 4 local m2 = 2+2 display `m2&#39; 4 Aber wenn wir uns mit mac list die abgelegten Infos ansehen, dann sehen wir den entscheidenden Unterschied: mac list _m1 _m2 _m1: 2+2 _m2: 4 Wenn wir nämlich mit m1 und m2 weiterrechnen, da kann folgendes passieren: local m1 2+2 display `m1&#39;*4 10 local m2 = 2+2 display `m2&#39;*4 16 Denn \\(2+2*4\\neq4*4\\) 1.2 local und global sind getrennte Welten Geht, aber ist nicht zu empfehlen: glo yx = 1 loc yx = 2 mac list yx mac list _yx yx: 1 _yx: 2 1.3 Macros mit Text Wir können macros zu Texten zusammenbauen: glo t1 &quot;Hallo&quot; glo t2 &quot; zusammen&quot; glo t3 &quot;! :-)&quot; glo t4 = &quot;${t1}${t2}${t3}&quot; dis &quot;${t4}&quot; mac list t1 t2 t3 t4 Hallo zusammen! :-) t1: Hallo t2: zusammen t3: ! :-) t4: Hallo zusammen! :-) Übung 1.4 Dateipfade Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden: glo pfad &quot;D:\\Projekt\\daten\\BIBB_BAuA&quot; // wo liegt der Datensatz? use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden: glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. Wir lernen gleich noch eine Möglichkeit kennen, das auch direkt mit zu lösen mit dem Usernamen der verwendeten PCs. use &quot;${data}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Die \" \" sind nicht zwingend nötig in diesem Fall. Sollten aber Leerzeichen im Pfad vorkommen, brauchen wir auf jeden Fall \" \". Außerdem ist \\ beim Zusammenbauen mit macros manchmal problematisch) - auch hier helfen \" \". Alternativ hilft hier / statt \\ zu verwenden. Mit mkdir können wir auch Ordner erstellen. Wenn also noch kein log-Ordner existiert, können wir ihn so erstellen: mkdir ${log} Mit cap cd können wir das vorher überprüfen: capture cd &quot;${log}&quot; if _rc!=0 { mkdir ${log} display &quot;${log} erstellt&quot; } Siehe 01_init_beispiel.do für ein Beispiel für einige Befehle beim Erstellen eines Projektverzeichnisses. 1.5 Bereits definierte Macros Mit mac list bekommen wir auch einige von Stata bereits vorgegebenen Macros angezeigt. mac list Zwei sehr nützliche sind dabei $S_DATE $S_TIME - das aktuelle Datum und die aktuelle Zeit: dis &quot;$S_DATE&quot; dis &quot;$S_TIME&quot; 1 Dec 2021 12:44:22 Diese können wir beispielsweise am Anfang und Ende eines Abschnitts in einem LogFiles einblenden, um Start- und Endzeit zu dokumentieren: log using &quot;${log}/logfile.txt&quot;, t replace use .... dis &quot;Start: $S_DATE um $S_TIME&quot; . . Hier kommen aufwändige Modelle . . . dis &quot;Ende: $S_DATE um $S_TIME&quot; . . . cap log close So können wir beispielsweise automatisch log-Files mit einem Datum versehen: global date = string( d($S_DATE), &quot;%tdCY-N-D&quot; ) * help datetime_display_formats // für andere Datumsformate cap log close log using &quot;${log}/01_macro_loops_${date}.log&quot;, replace text . log using &quot;${log}/01_macro_loops_${date}.log&quot;, replace text (note: file D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log not found) -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- name: &lt;unnamed&gt; log: D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log log type: text opened on: 01 Dec 2021, 10:45:04 Außerdem gibt es einige locals mit nützlichen Infos: dis &quot;`c(username)&#39;&quot; dis &quot;`c(machine_type)&#39;&quot; dis &quot;`c(os)&#39;&quot; Filser PC (64-bit x86-64) Windows Weitere system parameters and settings unter help creturn bspw.: c(changed) returns a numeric scalar equal to 0 if the dataset in memory has not changed since it was last saved and 1 otherwise. c(filename) returns a string containing the filename last specified with a use or save, such as \"C:\\Data\\auto.dta\". c(filedate) returns a string containing the date and time the file in c(filename) was last saved, such as 7 Jul 2016 13:51. 1.5.1 if Mit if (local== \"...\") können wir macros abgleichen, um Befehle nur unter bestimmten Bedingungen auszuführen: if (&quot;`c(username)&#39;&quot; == &quot;Filser&quot;) display &quot;Du bist Filser&quot; if (&quot;`c(username)&#39;&quot; != &quot;Fischer&quot;) display &quot;Du bist nicht Fischer&quot; Das können wir für den Fall von eben mit mehreren Nutzern nutzen: if (&quot;`c(username)&#39;&quot; == &quot;Alex&quot;) glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? if (&quot;`c(username)&#39;&quot; == &quot;Micha&quot;) glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Für if-Bedingungen stehen uns die üblichen Operatoren zur Verfügung, die wir auch aus den if-Statements in Befehlen kennen: &gt;, &lt;, ==, &gt;=, &lt;=, !=/~= (ungleich) Mit | können wir oder-Bedingungen stellen. inrange: einen Wertebereich auswählen loc x = 20 if `x&#39; &gt;= 20 &amp; `x&#39; &lt;= 30 display &quot;&amp; yes&quot; if inrange(`x&#39;,20,30) display &quot;inrange yes&quot; loc x = 19 if inrange(`x&#39;,20,30) display &quot;yes&quot; inlist: spezifische Werte angeben, um lange Folgen von | zu vermeiden: loc x = 20 if `x&#39; == 18 | `x&#39; == 20 | `x&#39; == 22 | `x&#39; == 28 display &quot;| yes&quot; if inlist(`x&#39;,18,20,22,28) display &quot;inlist yes&quot; 1.5.2 Macros als Variablennamen und Befehle Auch so etwas ist möglich: local n 200 su F`n&#39; Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- F200 | 17,953 36.24272 14.03048 1 99 Ein macro kann auch ein Programm sein: loc t tab `t&#39; mobil Mobilfunkin | terview | Freq. Percent Cum. ------------+----------------------------------- Festnetz | 14,008 70.00 70.00 Mobilfunk | 6,004 30.00 100.00 ------------+----------------------------------- Total | 20,012 100.00 \\(\\Rightarrow\\) sollen macros als Text verstanden werden, sind \"\" nötig: loc opt ja if inlist(`opt&#39;,&quot;ja&quot;,&quot;JA&quot;,&quot;Ja&quot;,&quot;ok&quot;) tab mobil ja not found r(111); end of do-file r(111); loc opt ja if inlist(&quot;`opt&#39;&quot;,&quot;ja&quot;,&quot;JA&quot;,&quot;Ja&quot;,&quot;ok&quot;) tab mobil Mobilfunkin | terview | Freq. Percent Cum. ------------+----------------------------------- Festnetz | 14,008 70.00 70.00 Mobilfunk | 6,004 30.00 100.00 ------------+----------------------------------- Total | 20,012 100.00 1.5.3 globals durchsuchen Mit Hilfe sog. Wildcards können wir Zeichen offen lassen: ? ersetzt ein Zeichen * mehrere oder keines glo x1 = 2 glo x2 &quot;das ist x2&quot; glo x 291 global allglo: all globals &quot;x*&quot; global allglo2: all globals &quot;x?&quot; mac l allglo2 allglo allglo2: x2 x1 allglo: x x2 x1 Hier haben wir auch schon die dritte Form der macro Definition kennengelernt, die sog. extended macro function, welche auf : folgt. Hier also all globals, im Laufe dieses Kurses werden wir noch zahlreiche dieser Funktionen kennenlernen. 1.6 Wenn nicht if, dann else Mit if haben wir die Möglichkeiten aber noch nicht ausgeschöpft - aus help if: if `n&#39;==1 { local word &quot;one&quot; } else if `n&#39;==2 { local word &quot;two&quot; } else if `n&#39;==3 { local word &quot;three&quot; } else { local word &quot;big&quot; } display &quot;`word&#39;&quot; Mit exit (help exit_program) können wir Stata zu einer Unterbrechung bringen: exit causes Stata to terminate the current process and returns control to the calling process. if &quot;`c(username)&#39;&quot; == &quot;Alex&quot; { glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? } else if &quot;`c(username)&#39;&quot; == &quot;Micha&quot; { glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? } else { display as error &quot;Hier fehlt der passende Pfad&quot; exit } tab mobil Hier fehlt der passende Pfad end of do-file Übung 1.7 Schleifen: foreach &amp; forvalues Schleifen helfen uns das DRY (Dont repeat yourself) Prinzip umzusetzen. tab S1 if zpalter &lt;= 19 tab S1 if zpalter &lt;= 24 tab S1 if zpalter &lt;= 29 foreach v of numlist 19(5)29 { display &quot;Alter bis `v&#39;&quot; tab S1 if zpalter &lt;= `v&#39; } Ein vereinfachtes Syntaxdiagramm der foreach-Schleife sieht so aus: foreach lname listtype list { Befehle } lname steht dabei für ein local macro. Wir können unterschiedliche Typen von foreach-Listen verwenden:  of varlist: Variablenlisten  of newlist: neue Variablen  of numlist: Nummernlisten - bspw. (0(1)5) \\(\\Rightarrow\\) 1 bis 5 in Schritten von 1 weitere Varianten  in: beliebige Listen von Buchstaben, Zahlen oder Wörtern (durch Leerzeichen getrennt) foreach lname in any_list { foreach lname of local local { foreach lname of global global { foreach lname of varlist variablen { //auch Wildcards möglich - analog zu d F2** foreach lname of newlist newvarlist { //wenn variablen erst generiert werden foreach lname of numlist numlist { foreach n of numlist 1/3 6(1)9 { dis &quot;`n&#39;&quot; } 1 2 3 6 7 8 9 foreach n of numlist 6 4: -4 { dis &quot;`n&#39;&quot; } 6 4 2 0 -2 -4 1.7.1 ferest() Mit ferest() können wir uns die noch übrigen Werte in der Liste anzeigen lassen: foreach n of numlist 1(1)5 { dis &quot;`n&#39;&quot; dis &quot;Es kommen noch: `ferest()&#39;&quot; } 1 Es kommen noch: 2 3 4 5 2 Es kommen noch: 3 4 5 3 Es kommen noch: 4 5 4 Es kommen noch: 5 5 Es kommen noch: 1.7.2 Weitere Schleifentypen Es gibt außerdem forvalues: forvalues lname=range { Befehle } forvalues-Schleife ist eine foreach-Schleife mit numlist. Aber: Die foreach-Schleife mit einer numlist funktioniert nicht mit einer beliebig hohen Anzahl von Ziffern. In der forvalues-Schleife gibt es keine Beschränkung. Außerdem ist forvalues-Schleife schneller im Abarbeiten von Nummernlisten. Und dann gibt es noch die while-Schleife: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc i = `i&#39; + 1 } 1 2 3 4 5 Eine Besonderheit bei locals ist, dass wir mit loc ++i den Wert um 1 erhöhen können. Somit führt folgende Syntax zum gleichen Ergebnis: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc ++i } 1.7.3 Anwendung foreach v of numlist 19(5)35 { display &quot;Alter bis `v&#39;&quot; tab S1 if zpalter &lt;= `v&#39; } Alter bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 373 65.10 65.10 weiblich | 200 34.90 100.00 ------------+----------------------------------- Total | 573 100.00 Alter bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 991 60.46 60.46 weiblich | 648 39.54 100.00 ------------+----------------------------------- Total | 1,639 100.00 Alter bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 1,984 59.03 59.03 weiblich | 1,377 40.97 100.00 ------------+----------------------------------- Total | 3,361 100.00 oder mit inrange(), um lediglich die 5-Jahresaltersgruppe anzuzeigen: foreach v of numlist 19(5)35 { display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; tab S1 if inrange(zpalter,`v&#39;-4, `v&#39;) *su zpalter if inrange(zpalter,`v&#39;-4, `v&#39;) } Alter 15 bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter 20 bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 332 64.84 64.84 weiblich | 180 35.16 100.00 ------------+----------------------------------- Total | 512 100.00 Alter 25 bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 618 57.97 57.97 weiblich | 448 42.03 100.00 ------------+----------------------------------- Total | 1,066 100.00 Alter 30 bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 993 57.67 57.67 weiblich | 729 42.33 100.00 ------------+----------------------------------- Total | 1,722 100.00 1.7.4 Schleifen aufbauen Einfache Schleife mit if/else: ist Zahl gerade oder ungerade? loc n = 5 if trunc(`n&#39;/2) == `n&#39;/2 display &quot;ja&quot; if trunc(`n&#39;/2) != `n&#39;/2 display &quot;nein&quot; loc n = 5 dis mod(`n&#39;,2) forvalues n = 1/10 { if mod(`n&#39;,2) == 0 dis &quot;`n&#39; ist gerade&quot; if mod(`n&#39;,2) &gt; 0 dis &quot;`n&#39; ist ungerade&quot; } forvalues n = 1/10 { if mod(`n&#39;,2) == 0 { dis &quot;`n&#39; ist gerade&quot; } else if mod(`n&#39;,2) &gt; 0 { dis &quot;`n&#39; ist ungerade&quot; } } mod() ist der Modulo-Operator in Stata - es wird der Rest berechnet 1.7.5 nested loop 1.7.6 display vs. macro list macro list stoppt das DoFile wenn der macro nicht existiert, display zeigt nur ein leeres Feld an: global labormarket LABOUR display &quot;${labormarket}&quot; display &quot;${labourmarket}&quot; LABOUR mac list labormarket mac list labourmarket labormarket: LABOUR global macro $labourmarket not found r(111); Übung 1.8 Übungen 1.8.1 Übung Was ist das Ergebnis dieser Rechnung? Nehmen Sie sich einen Moment Zeit und rechnen Sie im Kopf - Überprüfen Sie dann ihr Ergebnis. loc x = 4 glo y = 1+5 loc y 1+5 dis `x&#39; * `y&#39; Wie können Sie hier aus Hallo zusammen! :-) folgende Ausgabe machen: Hallo, zusammen! :-) ohne die macros zu verändern oder einen neuen anzulegen? glo t1 &quot;Hallo&quot; glo t2 &quot; zusammen&quot; glo t3 &quot;! :-)&quot; glo t4 = &quot;${t1}${t2}${t3}&quot; dis &quot;${t4}&quot; 1.8.2 Übung Pfad zusammenbauen für use: Erstellen Sie den Pfad für den use-Befehl schrittweise und unter Berücksichtigung Ihres Usernamens. ggf. Dateiverzeichnis einrichten mit Ordner log, prog und data (gerne auch mehr oder andere Namen) Legen Sie die Erwerbstätigenbefragung 2018 in den data-Ordner (oder dessen Äquivalent) Wie ist der Username auf Ihrem Gerät? Verwenden Sie ein if-Statement, um den Dateipfad zu erstellen Erstellen Sie ein LogFile, welches das heutige Datum im Namen trägt. Lassen Sie sich alle globals, die mit S beginnen, in ein gobal allS ablegen. Was wurde alles gefunden? Denken Sie an die extended macro function all globals Wie könnten Sie eine Schleife bauen, die nacheinander alle globals anzeigt, die mit S beginnen? 1.8.3 FizzBuzz-Challenge Fizz Buzz wird/wurde als ein Screening-Instrument für Programmierer*innen verwendet. Fizz Buzz ist ein Kinderlernspiel, bei dem die Kinder üblicherweise im Kreis sitzen und reihum laut von eins aufwärts zählen. Allerdings gibt es drei Regeln: Alle Zahlen, die durch drei teilbar sind, müssen durch das Wort Fizz ersetzt werden Alle Zahlen, die durch fünf teilbar sind, müssen durch das Wort Buzz ersetzt werden Wenn eine Zahl durch drei und fünf teilbar ist, dann wird Fizz Buzz gerufen. Diskutieren Sie erst in der Gruppe, wie Sie mit if &amp; else eine Schleife bauen würden, welche diese Regeln umsetzt. Was wäre der erste Schritt? Bauen Sie dann die Schleife und lassen Sie die Schleife für den Wertebereich 0-30 laufen. 1.8.4 Übung Passen Sie die Schleife mit ferest() an, sodass hier im 5. Durchlauf nicht mehr Es kommen noch: steht, sondern Fertig. 1.9 Anhang 1.9.1 Windows Dateipfade mit macros Aus der Stata-Doku zu macros: Stata uses the  character to tell its parser not to expand macros. Windows uses the  character as the directory path separator. Mostly, there is no problem using a  in a filename. However, if you are writing a program that contains a Windows path in macro path and a filename in fname, do not assemble the final result as path\\fname because Stata will interpret the  as an instruction to not expand fname. \\(\\Rightarrow\\) Instead, assemble the final result as path/fname. Stata understands / as a directory separator on all platforms. 1.9.2 Debugging: Wo ist der Wurm drin? Fehlersuch in langen foreach-Schleifen kann mühsam und nervig sein. in many cases you would like to go throuh the code step by step then, however, the value of the loop index (which is a local) In vielen Fällen möchte man den Code Schritt für Schritt durchgehen, dann aber den Wert des Schleifen-locals ist natürlich nach Abbruch der Schleife nicht mehr da. forvalues y = 1982/1985 { use &quot;${data}/wages-year`y&#39;&quot;, clear capture log close log using &quot;${data}/log`y&#39;.log&quot;, text replace regress lwage exper expersq educ avplots graph export &quot;${graph}/avplots`y&#39;.png&quot;, replace } Manchmal hilft ein einfacher Workaround: ein global aus dem local definieren: forvalues y = 1982/1985 { global Y = `y&#39; use &quot;${data}/wages-year`y&#39;&quot;, clear capture log close log using &quot;${data}/log`y&#39;.log&quot;, text replace regress lwage exper expersq educ avplots graph export &quot;${graph}/avplots`y&#39;.png&quot;, replace } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
