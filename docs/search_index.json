[["loopmacro.html", "2 Schleifen aus Macros 2.1 local erstellen und für Schleifen verwenden 2.2 Informationen aus Schleifen behalten 2.3 matrix 2.4 mehrere Kennzahlen ablegen 2.5 Matrixoperationen 2.6 Regressionsergebnisse 2.7 frame 2.8 statsby 2.9 Übungen", " 2 Schleifen aus Macros 2.1 local erstellen und für Schleifen verwenden Schleifen aus globals / locals mit Hilfe von levelsof: tab m1202 levelsof m1202 levelsof m1202, loc(ausb) foreach lvl of local ausb { dis &quot;m1202: &quot; `lvl&#39; } levelsof m1202, loc(ausb) glo ausb `ausb&#39; mac l ausb foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; } foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; tab S1 if m1202 == `lvl&#39; } 2.2 Informationen aus Schleifen behalten 2.2.1 Gespeichterte Ergebnisse Um auf Ergebnisse zuzugreifen, können wir etwas hinter die Kulissen der Stata-Befehle sehen: Befehl zeigt alle c-class system parameters &amp; settings finden wir als c() - siehe `c(username)' r-class die meisten deskriptiven Befehle speichern die Ergebnisse in in r() e-class außer estimation commands, wie bspw. reg - hier wird in e() gespeichert (Postestimates) s-class parsing commands store results in s() used by programmers n-class commands that do not store in r(), e(), oder s() Jeweils alle Werte anzeigen mit: Befehl zeigt alle return list r() ereturn list e() sreturn list s() creturn list c() Es gibt dabei vier Typen an Ergebnissen: macro: strings mit mehreren Wörtern (Text) matrix: bspw. e(b) sind die Koeffizienten nach einem reg-Befehl oder e(V) ist die VarianzKovarianz Matrix der estimates (VCE) scalar: einzelne Zahlen/Strings (1x1 Matrizen) functions: bspw. e(sample) \\(\\Rightarrow\\) 1 (true) wenn die Beobachtung im vorheringen estimation command verwendet wurde und 0 (false) wenn nicht tab S1 return list Geschlecht | Freq. Percent Cum. ------------+----------------------------------- mÃ¤nnlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 scalars: r(N) = 20012 r(r) = 2 su S1 return list Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- S1 | 20,012 1.496602 .5000009 1 2 scalars: r(N) = 20012 r(sum_w) = 20012 r(mean) = 1.496602038776734 r(Var) = .2500009464113147 r(sd) = .500000946410419 r(min) = 1 r(max) = 2 r(sum) = 29950 reg F518_SUF zpalter ereturn list Source | SS df MS Number of obs = 16,543 -------------+---------------------------------- F(1, 16541) = 105.36 Model | 1.3092e+09 1 1.3092e+09 Prob &gt; F = 0.0000 Residual | 2.0555e+11 16,541 12426773 R-squared = 0.0063 -------------+---------------------------------- Adj R-squared = 0.0063 Total | 2.0686e+11 16,542 12505168 Root MSE = 3525.2 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- zpalter | 24.62253 2.398848 10.26 0.000 19.92053 29.32453 _cons | 2381.28 115.577 20.60 0.000 2154.736 2607.823 ------------------------------------------------------------------------------ scalars: e(N) = 16543 e(df_m) = 1 e(df_r) = 16541 e(F) = 105.3561454498825 e(r2) = .0063290815436915 e(rmse) = 3525.162828161657 e(mss) = 1309236899.97876 e(rss) = 205551251614.9366 e(r2_a) = .0062690083366028 e(ll) = -158590.4618746699 e(ll_0) = -158642.9792418738 e(rank) = 2 macros: e(cmdline) : &quot;regress F518_SUF zpalter&quot; e(title) : &quot;Linear regression&quot; e(marginsok) : &quot;XB default&quot; e(vce) : &quot;ols&quot; e(depvar) : &quot;F518_SUF&quot; e(cmd) : &quot;regress&quot; e(properties) : &quot;b V&quot; e(predict) : &quot;regres_p&quot; e(model) : &quot;ols&quot; e(estat_cmd) : &quot;regress_estat&quot; matrices: e(b) : 1 x 2 e(V) : 2 x 2 functions: e(sample) Anstatt zu versuchen, den Überblick darüber zu behalten, was wo gespeichert wird, finden woe ganz unten in jeder Hilfedatei einen Hinweis wie summarize stores the following in r(): or mean stores the following in e() - entsprechend sehen wir die Ergebnisse in return bzw. ereturn. 2.2.2 e() und r() sind getrennte Welten Neben dem Prinzip One Data folgt Stata auch dem Prinzip One _-class. Das bedeutet, dass wir nur den return oder ereturn für den letzten Befehl dieser Klasse sehen können. Wenn wir also reg ausführen und dann eine Reihe von r-Klassen-Aufrufen machen (z.B. su), wird uns der Aufruf von ereturn immer noch die Werte für `reg`` anzeigen. Sobald wir jedoch einen weiteren r-class-Befehl ausführen, verlieren wir den Zugriff auf die Ergebnisse des ersten Befehls. reg az F200 su az ereturn list Source | SS df MS Number of obs = 17,376 -------------+---------------------------------- F(1, 17374) = 33637.44 Model | 1269310.92 1 1269310.92 Prob &gt; F = 0.0000 Residual | 655608.985 17,374 37.735063 R-squared = 0.6594 -------------+---------------------------------- Adj R-squared = 0.6594 Total | 1924919.9 17,375 110.786757 Root MSE = 6.1429 ------------------------------------------------------------------------------ az | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- F200 | .9897533 .0053965 183.41 0.000 .9791755 1.000331 _cons | 3.937849 .1903973 20.68 0.000 3.564651 4.311047 ------------------------------------------------------------------------------ Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- az | 20,012 38.30557 11.75297 10 120 scalars: e(N) = 17376 e(df_m) = 1 e(df_r) = 17374 e(F) = 33637.43995203968 e(r2) = .6594097320849045 e(rmse) = 6.142887188019294 e(mss) = 1269310.915908093 e(rss) = 655608.9846442067 e(r2_a) = .6593901286390708 e(ll) = -56197.03934279057 e(ll_0) = -65554.6676770772 e(rank) = 2 macros: e(cmdline) : &quot;regress az F200&quot; e(title) : &quot;Linear regression&quot; e(marginsok) : &quot;XB default&quot; e(vce) : &quot;ols&quot; e(depvar) : &quot;az&quot; e(cmd) : &quot;regress&quot; e(properties) : &quot;b V&quot; e(predict) : &quot;regres_p&quot; e(model) : &quot;ols&quot; e(estat_cmd) : &quot;regress_estat&quot; matrices: e(b) : 1 x 2 e(V) : 2 x 2 functions: e(sample) 2.2.3 Ergebnisse weiter verwenden Alle diese Informationen können wir mit einem Makro speichern bzw. weiter verarbeiten. su S1 dis &quot;Mittelwert beträgt: &quot; r(mean) Der Mittelwert beträgt: 1.496602 su S1 dis &quot;Mittelwert beträgt: &quot; round(r(mean),.01) Der Mittelwert beträgt: 1.5 foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; su S01 if m1202 == `lvl&#39; dis r(mean) } foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; dis &quot;Der Frauenanteil in m1202=&quot; `lvl&#39; &quot; beträgt: &quot; round(r(mean)*100,.1) &quot;%&quot; } foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; glo gend`lvl&#39;: display &quot;Der Frauenanteil in m1202=&quot; `lvl&#39; &quot; beträgt: &quot; round(r(mean)*100,.1) &quot;%&quot; } Macros können auch recursively erstellt werden: global x &quot;&quot; forvalues i = 1/20 { global x $x `i&#39; } mac list x x: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 somit können wir einen global auch zusammenbauen: glo gend &quot;&quot; foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; glo gend: display &quot;${gend}m1202=&quot; `lvl&#39; &quot; &quot; round(r(mean)*100,.1) &quot;% &quot; } mac l gend 4. } gend: m1202=1 45.6% m1202=2 53% m1202=3 37.8% m1202=4 48.9% 2.3 matrix Matrizen helfen uns, die ergebnisse in handhabarer Form zu speichern (help matrix). eine matrix ausgeben: matrix list matname eine matrix umbenennen: matrix umbenennen altername neuername eine matrix oder alle löschen: matrix drop [matlist] Mit J(Zeilen,Spalten,Inhalt) können wir eine Matrix mit gleichen Werten besetzen: mat G0 = J(4,2,0) mat l G0 G0[4,2] c1 c2 r1 0 0 r2 0 0 r3 0 0 r4 0 0  mit . in allen Zellen: mat Gx = J(4,2,.) mat l Gx Gx[4,2] c1 c2 r1 . . r2 . . r3 . . r4 . . Mit mat name[Spalte,Zeile] können wir auf einen Teilbereich zugreifen: mat A = J(4,2,7) mat A[3,2] = 2 mat list A A[4,2] c1 c2 r1 7 7 r2 7 7 r3 7 2 r4 7 7 Das nutzen wir jetzt um unsere Ergebnisse zu speichern: levelsof m1202, loc(ausb) glo ausb `ausb&#39; mat G = J(4,2,.) // leere Matrix mat l G mat colname G = m1202 share_w mat l G foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; mat G[`lvl&#39;,1] = `lvl&#39; // 1. Spalte level von m1202 mat G[`lvl&#39;,2] = r(mean)*100 //2.Spalte: Frauenanteil } help matrix operators Operator Symbol column join , row join \\ transpose  negation - matrix Y1 = 1, 3 mat l Y1 Y1[1,2] c1 c2 r1 1 3 matrix Y2 = 4\\ 0 mat l Y2 Y2[2,1] c1 r1 4 r2 0 matrix Y = (2, 1.5 \\ 2.5, 3) mat l Y Y[2,2] c1 c2 r1 2 1.5 r2 2.5 3 Wir können auch Rechnungen einfügen: matrix X1 = (1+1, 2*3/4 \\ 5/2, 3) mat l X1 X1[2,2] c1 c2 r1 2 1.5 r2 2.5 3 Transponieren: matrix X2 = (1, 2, 3 \\ 5 , 8 , 9) mat l X2 mat X3 = X2&#39; mat l X3 X2[2,3] c1 c2 c3 r1 1 2 3 r2 5 8 9 X3[3,2] r1 r2 c1 1 5 c2 2 8 c3 3 9 2.4 mehrere Kennzahlen ablegen Damit können wir zeilenweise eine matrix befüllen: mat G2 = J(4,5,.) // leere Matrix mat l G2 mat colname G2 = m1202 p25 mean median p75 mat l G2 foreach lvl of global ausb { qui su zpalter if m1202 == `lvl&#39;, det mat GX = `lvl&#39;, r(p25), r(mean), r(p50), r(p75) mat G2[`lvl&#39;,1] = GX } mat l G2 G2[4,5] m1202 p25 mean median p75 r1 1 29 42.627213 46 55 r2 2 39 47.076531 49 56 r3 3 41 48.092344 50 56 r4 4 39 47.760744 49 57 Übung 2.5 Matrixoperationen 2.5.1 Teilmatrizen mat X1 = (1,2,3,4,5 \\ 6,7,8,9,10 \\ 0,-1,-2,-3,-5 \\ -6,-7,-8,-9,-10) mat l X1 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 Wir können aus diesen Matrizen auch Teilbereiche auswählen: matrix newmat = oldmat[Zeile(nbereich), Spalte(nbereich)] Zeilenbereich und Spaltenbereich können einzelne Zahlen oder Bereiche mit durch zwei Punkte getrennten Start- und Endpositionen sein. Matrix B erstellen, welche die Zeile 2-4 und die Spalte 1-5 von X1 enthält: matrix B = X1[2..4,1..5] mat l B mat l X1 B[3,5] c1 c2 c3 c4 c5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 Um alle Zeilen nach der zweiten Zeile zu übernehmen, verwenden wir drei Punkte: matrix C = X1[2...,1..5] mat l C mat l X1 C[3,5] c1 c2 c3 c4 c5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 matrix A = J(3,4,.) mat li A A[3,4] c1 c2 c3 c4 r1 . . . . r2 . . . . r3 . . . . mat A1 = (1, 4, 2, 1) mat li A1 A1[1,4] c1 c2 c3 c4 r1 1 4 2 1 mat A[1,1] =A1 // !! überschreibt die ganze 1. Zeile mat li A A[3,4] c1 c2 c3 c4 r1 1 4 2 1 r2 . . . . r3 . . . . 2.5.2 matrix zu Datensatz svmat coeff_, names(matcol) 2.6 Regressionsergebnisse Die Koeffizienten und Standardfehler des letzten Modells werden in e() gespeichert: reg F518_SUF F200 Source | SS df MS Number of obs = 14,659 -------------+---------------------------------- F(1, 14657) = 1370.76 Model | 1.3122e+10 1 1.3122e+10 Prob &gt; F = 0.0000 Residual | 1.4031e+11 14,657 9572601.57 R-squared = 0.0855 -------------+---------------------------------- Adj R-squared = 0.0855 Total | 1.5343e+11 14,658 10467142.3 Root MSE = 3094 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- F200 | 109.4473 2.956134 37.02 0.000 103.6529 115.2417 _cons | -344.1221 104.2802 -3.30 0.001 -548.5245 -139.7197 ------------------------------------------------------------------------------ mat l e(b) e(b)[1,2] F200 _cons y1 109.44727 -344.12212 Allerdings gibt es noch eine Abkürzung mit _b[varname] bzw. _se[varname]: dis &quot;Der Koeffizient für F200 ist &quot; _b[F200] dis &quot;Der Standardfehler des Koeffizienten für F200 ist &quot; _se[F200] Der Koeffizient für F200 ist 109.44727 Der Standardfehler des Koeffizienten für F200 ist 2.9561335 Wir können so auch vorhergesagte Werte berechnen - entweder für spezifische Werte: dis _b[_cons] + 20 *_b[F200] margins, at(F200 = 20) 1844.8234 Adjusted predictions Number of obs = 14,659 Model VCE : OLS Expression : Linear prediction, predict() ------------------------------------------------------------------------------ | Delta-method | Margin Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- _cons | 1844.823 49.14441 37.54 0.000 1748.494 1941.153 ------------------------------------------------------------------------------ oder für alle Beobachtungen: gen pred_manual = _b[_cons] + F200 *_b[F200] predict pred_auto, xb gen diff= pred_manual - pred_auto su diff Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- diff | 17,376 0 0 0 0 2.7 frame 2.8 statsby statsby _b _se, by(Bula) noisily: /// regress F518_SUF c.F200##c.F200 i.m1202 i.S1 Übung 2 2.9 Übungen 2.9.1 Übung Erstellen Sie eine Schleife, welche jeweils das Maximaleinkommen (basierend auf F518_SUF) für die Gemeindegrößenklassen (gkpol) anzeigt. Schließen Sie mit mvdecode F518_SUF, mv( 99998/ 99999) missings aus Wie kommen Sie an den Maximalwert für F518_SUF? Verwenden Sie bspw. su oder tabstat zusammen mit return list. Erstellen Sie mit display eine aussagekräftige Ausgabe Testen Sie Ihre Schleifenlogik mit einem local, um anschließend die Schleife außen herumzubauen Welche Ausprägungen hat gkpol - wie können Sie diese automatisch in eine Schleife überführen? Sammeln Sie die Ergebnisse jetzt in einer matrix Erstellen Sie eine leere matrix mit der passenden Anzahl an Zeilen und Spalten Kopieren Sie die oben erstellte Schleife und passen Sie diese so an, dass die Werte (zusätzlich zu Anzeige) in dieser matrix gesammelt werden. Stimmen die Werte? Passen Sie Ihre Schleife an, sodass für jeden Durchlauf ein global gkX erstellt wird, wobei X für die Ausprägung von gkpol steht und den entsprechenden Maximalwert von F518_SUF für die entsprechende Größenklasse enthält. 2.9.2 Übung nur bei N &gt; 20 2.9.3 Übung save the coefficients in a separate data set graph the educ and union coefficients against year "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
